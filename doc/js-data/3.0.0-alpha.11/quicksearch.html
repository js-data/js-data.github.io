<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Collection.js import Query from './Query' import { _, addHiddenPropsToTarget, classCallCheck, deepMixIn, eventify, extend, fillIn, forOwn, get, isArray, isFunction, isObject, isSorN, isString } from './utils' import {Index} from '../lib/mindex/index' const COLLECTION_DEFAULTS = { /** * Field to be used as the unique identifier for records in this collection. * Defaults to `&quot;id&quot;` unless {@link Collection#mapper} is set, in which case * this will default to {@link Mapper#idAttribute}. * * @name Collection#idAttribute * @type {string} * @default &quot;id&quot; */ idAttribute: 'id', /** * Default Mapper for this collection. Optional. If a Mapper is provided, then * the collection will use the {@link Mapper#idAttribute} setting, and will * wrap records in {@link Mapper#RecordClass}. * * @example * import {Collection, Mapper} from 'js-data' * * class MyMapperClass extends Mapper { * foo () { return 'bar' } * } * const myMapper = new MyMapperClass() * const collection = new Collection(null, { mapper: myMapper }) * * @name Collection#mapper * @type {Mapper} * @default null */ mapper: null, /** * What to do when inserting a record into this Collection that shares a * primary key with a record already in this Collection. * * Possible values: * - merge * - replace * * Merge: * * Recursively shallow copy properties from the new record onto the existing * record. * * Replace: * * Shallow copy top-level properties from the new record onto the existing * record. Any top-level own properties of the existing record that are _not_ * on the new record will be removed. * * @name Collection#onConflict * @type {string} * @default &quot;merge&quot; */ onConflict: 'merge', /** * Options to be passed into {@link Mapper#createRecord} when wrapping records * in {@link Mapper#RecordClass}. * * @name Collection#recordOpts * @type {Object} * @default null */ recordOpts: null } /** * ```javascript * import {Collection} from 'js-data' * ``` * * An ordered set of {@link Record} instances. * * @example * import {Collection, Record} from 'js-data' * const user1 = new Record({ id: 1 }) * const user2 = new Record({ id: 2 }) * const UserCollection = new Collection([user1, user2]) * UserCollection.get(1) === user1 // true * * @class Collection * @param {Array} [records] Initial set of records to insert into the * collection. * @param {Object} [opts] Configuration options. * @param {string} [opts.idAttribute] See {@link Collection#idAttribute}. * @param {string} [opts.onConflict=&quot;merge&quot;] See {@link Collection#onConflict}. * @param {string} [opts.mapper] See {@link Collection#mapper}. * @param {Object} [opts.recordOpts=null] See {@link Collection#recordOpts}. */ export default function Collection (records, opts) { const self = this classCallCheck(self, Collection) if (isObject(records) &amp;&amp; !isArray(records)) { opts = records records = [] } if (isString(opts)) { opts = { idAttribute: opts } } // Default values for arguments records || (records = []) opts || (opts = {}) opts.recordOpts || (opts.recordOpts = {}) fillIn(self, opts) fillIn(self, COLLECTION_DEFAULTS) /** * Event listeners attached to this Collection. * * @name Collection#_listeners * @instance * @type {Object} * @private */ self._listeners = {} const idAttribute = self.recordId() /** * The main index, which uses @{link Collection#recordId} as the key. * @name Collection#index * @type {Index} */ self.index = new Index([idAttribute], { hashCode (obj) { return get(obj, idAttribute) } }) /** * Object that holds the secondary indexes of this collection. * @name Collection#indexes * @type {Object.&lt;string, Index&gt;} */ self.indexes = {} records.forEach(function (record) { record = self.mapper ? self.mapper.createRecord(record, self.recordOpts) : record self.index.insertRecord(record) if (record &amp;&amp; isFunction(record.on)) { record.on('all', self._onRecordEvent, self) } }) } /** * Create a Collection subclass. * * @example * var MyCollection = Collection.extend({ * foo: function () { return 'bar' } * }) * var collection = new MyCollection() * collection.foo() // &quot;bar&quot; * * @name Collection.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of Collection. */ Collection.extend = extend addHiddenPropsToTarget(Collection.prototype, { /** * Used to bind to events emitted by records in this Collection. * * @name Collection#_onRecordEvent * @method * @private * @param {...*} [arg] Args passed to {@link Collection#emit}. */ _onRecordEvent (...args) { this.emit(...args) }, /** * Insert the provided record or records. * * If a record is already in the collection then the provided record will * either merge with or replace the existing record based on the value of the * `onConflict` option. * * The collection's secondary indexes will be updated as each record is * visited. * * @name Collection#add * @method * @param {(Object|Object[]|Record|Record[])} data The record or records to insert. * @param {Object} [opts] Configuration options. * @param {string} [opts.onConflict] What to do when a record is already in * the collection. Possible values are `merge` or `replace`. * @return {(Object|Object[]|Record|Record[])} The added record or records. */ add (records, opts) { const self = this // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Collection's configuration _(self, opts) records = self.beforeAdd(records, opts) || records // Track whether just one record or an array of records is being inserted let singular = false const idAttribute = self.recordId() if (!isArray(records)) { records = [records] singular = true } // Map the provided records to existing records. // New records will be inserted. If any records map to existing records, // they will be merged into the existing records according to the onConflict // option. records = records.map(function (record) { let id = self.recordId(record) if (!isSorN(id)) { throw new TypeError(`${idAttribute}: Expected string or number, found ${typeof id}!`) } // Grab existing record if there is one const existing = self.get(id) // If the currently visited record is just a reference to an existing // record, then there is nothing to be done. Exit early. if (record === existing) { return existing } if (existing) { // Here, the currently visited record corresponds to a record already // in the collection, so we need to merge them const onConflict = opts.onConflict || self.onConflict if (onConflict === 'merge') { deepMixIn(existing, record) } else if (onConflict === 'replace') { forOwn(existing, (value, key) =&gt; { if (key !== idAttribute &amp;&amp; !record.hasOwnProperty(key)) { delete existing[key] } }) existing.set(record) } record = existing // Update all indexes in the collection self.updateIndexes(record) } else { // Here, the currently visted record does not correspond to any record // in the collection, so (optionally) instantiate this record and insert // it into the collection record = self.mapper ? self.mapper.createRecord(record, self.recordOpts) : record self.index.insertRecord(record) forOwn(self.indexes, function (index, name) { index.insertRecord(record) }) if (record &amp;&amp; isFunction(record.on)) { record.on('all', self._onRecordEvent, self) } } return record }) // Finally, return the inserted data const result = singular ? (records.length ? records[0] : undefined) : records // TODO: Make this more performant (batch events?) self.emit('add', result) return self.afterAdd(records, opts, result) || result }, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then {@link Collection#add} will return that same value. * * @name Collection#method * @method * @param {(Object|Object[]|Record|Record[])} result The record or records * that were added to this Collection by {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ afterAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. If this method returns * a value then {@link Collection#remove} will return that same value. * * @name Collection#afterRemove * @method * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. * @param {Object} record The result that will be returned by {@link Collection#remove}. */ afterRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. If this method * returns a value then {@link Collection#removeAll} will return that same * value. * * @name Collection#afterRemoveAll * @method * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. * @param {Object} records The result that will be returned by {@link Collection#removeAll}. */ afterRemoveAll () {}, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then the `records` argument in {@link Collection#add} will be * re-assigned to the returned value. * * @name Collection#beforeAdd * @method * @param {(Object|Object[]|Record|Record[])} records The `records` argument passed to {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ beforeAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. * * @name Collection#beforeRemove * @method * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. */ beforeRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. * * @name Collection#beforeRemoveAll * @method * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. */ beforeRemoveAll () {}, /** * Find all records between two boundaries. * * Shortcut for `collection.query().between(18, 30, { index: 'age' }).run()` * * @example &lt;caption&gt;Get all users ages 18 to 30&lt;/caption&gt; * const users = collection.between(18, 30, { index: 'age' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const users = collection.between([18], [30], { index: 'age' }) * * @name Collection#between * @method * @param {Array} leftKeys Keys defining the left boundary. * @param {Array} rightKeys Keys defining the right boundary. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include records * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include records * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting records to skip. * @return {Array} The result. */ between (leftKeys, rightKeys, opts) { return this.query().between(leftKeys, rightKeys, opts).run() }, /** * Create a new secondary index on the contents of the collection. * * @example &lt;caption&gt;Index users by age&lt;/caption&gt; * collection.createIndex('age') * * @example &lt;caption&gt;Index users by status and role&lt;/caption&gt; * collection.createIndex('statusAndRole', ['status', 'role']) * * @name Collection#createIndex * @method * @param {string} name - The name of the new secondary index. * @param {string[]} [fieldList] - Array of field names to use as the key or * compound key of the new secondary index. If no fieldList is provided, then * the name will also be the field that is used to index the collection. * @return {Collection} A reference to itself for chaining. */ createIndex (name, fieldList, opts) { const self = this if (isString(name) &amp;&amp; fieldList === undefined) { fieldList = [name] } opts || (opts = {}) opts.hashCode = opts.hashCode || function (obj) { return self.recordId(obj) } const index = self.indexes[name] = new Index(fieldList, opts) self.index.visitAll(index.insertRecord, index) return self }, /** * Find the record or records that match the provided query or pass the * provided filter function. * * Shortcut for `collection.query().filter(queryOrFn[, thisArg]).run()` * * @example &lt;caption&gt;Get the draft posts created less than three months&lt;/caption&gt; * const posts = collection.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }) * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = collection.filter(function (post) { * return post.isReady() * }) * * @name Collection#filter * @method * @param {(Object|Function)} [queryOrFn={}] - Selection query or filter * function. * @param {Object} [thisArg] - Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @return {Array} The result. */ filter (query, thisArg) { return this.query().filter(query, thisArg).run() }, /** * Iterate over all records. * * @example * collection.forEach(function (record) { * // do something * }) * * @name Collection#forEach * @method * @param {Function} forEachFn - Iteration function. * @param {*} [thisArg] - Context to which to bind `forEachFn`. * @return {Array} The result. */ forEach (cb, thisArg) { this.index.visitAll(cb, thisArg) }, /** * Get the record with the given id. * * @name Collection#get * @method * @param {(string|number)} id - The primary key of the record to get. * @return {(Object|Record)} The record with the given id. */ get (id) { const instances = this.query().get(id).run() return instances.length ? instances[0] : undefined }, /** * Find the record or records that match the provided keyLists. * * Shortcut for `collection.query().getAll(keyList1, keyList2, ...).run()` * * @example &lt;caption&gt;Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;&lt;/caption&gt; * const posts = collection.getAll('draft', 'inReview', { index: 'status' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) * * @name Collection#getAll * @method * @param {...Array} [keyList] - Provide one or more keyLists, and all * records matching each keyList will be retrieved. If no keyLists are * provided, all records will be returned. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] - Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @return {Array} The result. */ getAll (...args) { return this.query().getAll(...args).run() }, /** * Limit the result. * * Shortcut for `collection.query().limit(maximumNumber).run()` * * @example * const posts = collection.limit(10) * * @name Collection#limit * @method * @param {number} num - The maximum number of records to keep in the result. * @return {Array} The result. */ limit (num) { return this.query().limit(num).run() }, /** * Apply a mapping function to all records. * * @example * const names = collection.map(function (user) { * return user.name * }) * * @name Collection#map * @method * @param {Function} mapFn - Mapping function. * @param {*} [thisArg] - Context to which to bind `mapFn`. * @return {Array} The result of the mapping. */ map (cb, thisArg) { const data = [] this.index.visitAll(function (value) { data.push(cb.call(thisArg, value)) }) return data }, /** * Return the result of calling the specified function on each record in this * collection's main index. * * @name Collection#mapCall * @method * @param {string} funcName - Name of function to call * @parama {...*} [args] - Remaining arguments to be passed to the function. * @return {Array} The result. */ mapCall (funcName, ...args) { const data = [] this.index.visitAll(function (record) { data.push(record[funcName](...args)) }) return data }, /** * Return the primary key of the given, or if no record is provided, return the * name of the field that holds the primary key of records in this Collection. * * @name Collection#recordId * @method * @param {(Object|Record)} [record] The record whose primary key is to be * returned. * @return {(string|number)} Primary key or name of field that holds primary * key. */ recordId (record) { if (record) { return get(record, this.recordId()) } const self = this return self.mapper ? self.mapper.idAttribute : self.idAttribute || 'id' }, /** * Create a new query to be executed against the contents of the collection. * The result will be all or a subset of the contents of the collection. * * @example &lt;caption&gt;Grab page 2 of users between ages 18 and 30&lt;/caption&gt; * collection.query() * .between(18, 30, { index: 'age' }) // between ages 18 and 30 * .skip(10) // second page * .limit(10) // page size * .run() * * @name Collection#query * @method * @return {Query} New query object. */ query () { return new Query(this) }, /** * Reduce the data in the collection to a single value and return the result. * * @example * const totalVotes = collection.reduce(function (prev, record) { * return prev + record.upVotes + record.downVotes * }, 0) * * @name Collection#reduce * @method * @param {Function} cb - Reduction callback. * @param {*} initialValue - Initial value of the reduction. * @return {*} The result. */ reduce (cb, initialValue) { const data = this.getAll() return data.reduce(cb, initialValue) }, /** * Remove the record with the given id from this Collection. * * @name Collection#remove * @method * @param {(string|number)} id - The primary key of the record to be removed. * @param {Object} [opts] - Configuration options. * @return {Object|Record} The removed record, if any. */ remove (id, opts) { const self = this // Default values for arguments opts || (opts = {}) self.beforeRemove(id, opts) const record = self.get(id) // The record is in the collection, remove it if (record) { self.index.removeRecord(record) forOwn(self.indexes, function (index, name) { index.removeRecord(record) }) if (record &amp;&amp; isFunction(record.off)) { record.off('all', self._onRecordEvent, self) self.emit('remove', record) } } return self.afterRemove(id, opts, record) || record }, /** * Remove the record selected by &quot;query&quot; from this collection. * * @name Collection#removeAll * @method * @param {Object} [query={}] - Selection query. * @param {Object} [query.where] - Filtering criteria. * @param {number} [query.skip] - Number to skip. * @param {number} [query.limit] - Number to limit to. * @param {Array} [query.orderBy] - Sorting criteria. * @param {Object} [opts] - Configuration options. * @return {(Object[]|Record[])} The removed records, if any. */ removeAll (query, opts) { const self = this // Default values for arguments opts || (opts = {}) self.beforeRemoveAll(query, opts) const records = self.filter(query) // Remove each selected record from the collection records.forEach(function (item) { self.remove(self.recordId(item)) }) return self.afterRemoveAll(query, opts, records) || records }, /** * Skip a number of results. * * Shortcut for `collection.query().skip(numberToSkip).run()` * * @example * const posts = collection.skip(10) * * @name Collection#skip * @method * @param {number} num - The number of records to skip. * @return {Array} The result. */ skip (num) { return this.query().skip(num).run() }, /** * Return the plain JSON representation of all items in this collection. * Assumes records in this collection have a toJSON method. * * @name Collection#toJSON * @method * @param {Object} [opts] - Configuration options. * @param {string[]} [opts.with] - Array of relation names or relation fields * to include in the representation. * @return {Array} The records. */ toJSON (opts) { return this.mapCall('toJSON', opts) }, /** * Update a record's position in a single index of this collection. See * {@link Collection#updateIndexes} to update a record's position in all * indexes at once. * * @name Collection#updateIndex * @method * @param {Object} record - The record to update. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] The index in which to update the record's * position. If you don't specify an index then the record will be updated * in the main index. */ updateIndex (record, opts) { opts || (opts = {}) const index = opts.index ? this.indexes[opts.index] : this.index index.updateRecord(record) }, /** * TODO * * @name Collection#updateIndexes * @method * @param {Object} record - TODO * @param {Object} [opts] - Configuration options. */ updateIndexes (record) { const self = this self.index.updateRecord(record) forOwn(self.indexes, function (index, name) { index.updateRecord(record) }) } }) /** * TODO * * @name Collection#on * @method * @param {string} event TODO. * @param {Function} handler TODO */ /** * TODO * * @name Collection#off * @method * @param {string} [event] TODO. * @param {Function} [handler] TODO */ /** * TODO * * @name Collection#emit * @method * @param {string} event TODO. * @param {...*} [arg] TODO */ eventify( Collection.prototype, function () { return this._listeners }, function (value) { this._listeners = value } ) × Search results Close Back to js-data.io "},"Container.js.html":{"id":"Container.js.html","title":"Source: Container.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Container.js import { addHiddenPropsToTarget, classCallCheck, extend, fillIn, forOwn, isObject, isString } from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import Mapper from './Mapper' /** * ```javascript * import {Container} from 'js-data' * ``` * * The `Container` class is a place to store {@link Mapper} instances. * * Without a container, you need to manage mappers yourself, including resolving * circular dependencies among relations. All mappers in a container share the * same adapters, so you don't have to add each adapter to all of your mappers. * * @example &lt;caption&gt;Without Container&lt;/caption&gt; * import {Mapper} from 'js-data' * import HttpAdapter from 'js-data-http' * const adapter = new HttpAdapter() * const userMapper = new Mapper({ name: 'user' }) * userMapper.registerAdapter('http', adapter, { default: true }) * const commentMapper = new Mapper({ name: 'comment' }) * commentMapper.registerAdapter('http', adapter, { default: true }) * * // This might be more difficult if the mappers were defined in different * // modules. * userMapper.hasMany(commentMapper, { * localField: 'comments', * foreignKey: 'userId' * }) * commentMapper.belongsTo(userMapper, { * localField: 'user', * foreignKey: 'userId' * }) * * @example &lt;caption&gt;With Container&lt;/caption&gt; * import {Container} from 'js-data' * import HttpAdapter from 'js-data-http' * const container = new Container() * // All mappers in container share adapters * container.registerAdapter('http', new HttpAdapter(), { default: true }) * * // These could be defined in separate modules without a problem. * container.defineMapper('user', { * relations: { * hasMany: { * comment: { * localField: 'comments', * foreignKey: 'userId' * } * } * } * }) * container.defineMapper('comment', { * relations: { * belongsTo: { * user: { * localField: 'user', * foreignKey: 'userId' * } * } * } * }) * * @class Container * @param {Object} [opts] Configuration options. * @param {Function} [opts.MapperClass] Constructor function to use in * {@link Container#defineMapper} to create a new mapper. * @param {Object} [opts.mapperDefaults] Defaults options to pass to * {@link Container#MapperClass} when creating a new mapper. * @return {Container} */ export default function Container (opts) { const self = this classCallCheck(self, Container) opts || (opts = {}) // Apply options provided by the user fillIn(self, opts) /** * Defaults options to pass to {@link Container#MapperClass} when creating a * new mapper. * * @name Container#mapperDefaults * @type {Object} */ self.mapperDefaults = self.mapperDefaults || {} /** * Constructor function to use in {@link Container#defineMapper} to create a * new mapper. * * @name Container#MapperClass * @type {Function} */ self.MapperClass = self.MapperClass || Mapper // Initilize private data // Holds the adapters, shared by all mappers in this container self._adapters = {} // The the mappers in this container self._mappers = {} } /** * Create a Container subclass. * * @example * var MyContainer = Container.extend({ * foo: function () { return 'bar' } * }) * var container = new MyContainer() * container.foo() // &quot;bar&quot; * * @name Container.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of Container. */ Container.extend = extend addHiddenPropsToTarget(Container.prototype, { /** * Create a new mapper and register it in this container. * * @example * import {Container} from 'js-data' * const container = new Container({ * mapperDefaults: { foo: 'bar' } * }) * const userMapper = container.defineMapper('user') * userMapper.foo // &quot;bar&quot; * * @name Container#defineMapper * @method * @param {string} name Name under which to register the new {@link Mapper}. * {@link Mapper#name} will be set to this value. * @param {Object} [opts] Configuration options. Passed to * {@link Container#MapperClass} when creating the new {@link Mapper}. * @return {Mapper} */ defineMapper (name, opts) { const self = this // For backwards compatibility with defineResource if (isObject(name)) { opts = name if (!opts.name) { throw new Error('name is required!') } name = opts.name } else if (!isString(name)) { throw new Error('name is required!') } // Default values for arguments opts || (opts = {}) // Set Mapper#name opts.name = name opts.relations || (opts.relations = {}) // Check if the user is overriding the datastore's default MapperClass const MapperClass = opts.MapperClass || self.MapperClass delete opts.MapperClass // Apply the datastore's defaults to the options going into the mapper fillIn(opts, self.mapperDefaults) // Instantiate a mapper const mapper = self._mappers[name] = new MapperClass(opts) // Make sure the mapper's name is set mapper.name = name // All mappers in this datastore will share adapters mapper._adapters = self.getAdapters() // Setup the mapper's relations, including generating Mapper#relationList // and Mapper#relationFields forOwn(mapper.relations, function (group, type) { forOwn(group, function (relations, _name) { if (isObject(relations)) { relations = [relations] } relations.forEach(function (def) { def.getRelation = function () { return self.getMapper(_name) } const Relation = self._mappers[_name] || _name if (type === belongsToType) { mapper.belongsTo(Relation, def) } else if (type === hasOneType) { mapper.hasOne(Relation, def) } else if (type === hasManyType) { mapper.hasMany(Relation, def) } }) }) }) return mapper }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @name Container#getAdapterName * @method * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @return {string} The name of the adapter. */ getAdapterName (opts) { opts || (opts = {}) if (isString(opts)) { opts = { adapter: opts } } return opts.adapter || this.mapperDefaults.defaultAdapter }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @name Container#getAdapter * @method * @param {string} [name] The name of the adapter to retrieve. * @return {Adapter} The adapter. */ getAdapter (name) { const self = this const adapter = self.getAdapterName(name) if (!adapter) { throw new ReferenceError(`${adapter} not found!`) } return self.getAdapters()[adapter] }, /** * Return the registered adapters of this container. * * @name Container#getAdapters * @method * @return {Adapter} */ getAdapters () { return this._adapters }, /** * Return the mapper registered under the specified name. * * @example * import {Container} from 'js-data' * const container = new Container() * const userMapper = container.defineMapper('user') * userMapper === container.getMapper('user') // true * * @name Container#getMapper * @method * @param {string} name {@link Mapper#name}. * @return {Mapper} */ getMapper (name) { const mapper = this._mappers[name] if (!mapper) { throw new ReferenceError(`${name} is not a registered mapper!`) } return mapper }, /** * Register an adapter on this container under the given name. Adapters * registered on a container are shared by all mappers in the container. * * @example * import {Container} from 'js-data' * import HttpAdapter from 'js-data-http' * const container = new Container() * container.registerAdapter('http', new HttpAdapter, { default: true }) * * @name Container#registerAdapter * @method * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for all Mappers in this container. */ registerAdapter (name, adapter, opts) { const self = this opts || (opts = {}) self.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { self.mapperDefaults.defaultAdapter = name forOwn(self._mappers, function (mapper) { mapper.defaultAdapter = name }) } } }) × Search results Close Back to js-data.io "},"DataStore.js.html":{"id":"DataStore.js.html","title":"Source: DataStore.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: DataStore.js import { classCallCheck, extend, fillIn, getSuper, isBrowser } from './utils' import Container from './Container' import LinkedCollection from './LinkedCollection' const DATASTORE_DEFAULTS = { linkRelations: isBrowser } /** * The `DataStore` class is an extension of {@link Container}. Not only does * `DataStore` manage mappers, but also collections. `DataStore` implements the * asynchronous {@link Mapper} methods, such as {@link Mapper#find} and * {@link Mapper#create}. If you use the asynchronous `DataStore` methods * instead of calling them directly on the mappers, then the results of the * method calls will be inserted into the store's collections. You can think of * a `DataStore` as an [Identity Map](https://en.wikipedia.org/wiki/Identity_map_pattern) * for the [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping) * (the Mappers). * * ```javascript * import {DataStore} from 'js-data' * ``` * * @example * import {DataStore} from 'js-data' * import HttpAdapter from 'js-data-http' * const store = new DataStore() * const UserMapper = store.defineMapper('user') * * // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) * UserMapper.find(1).then(function (user) { * // retrieved a &quot;user&quot; record via the http adapter, but that's it * * // Call &quot;find&quot; on &quot;store&quot; for the &quot;user&quot; mapper (Stateful DataStore) * return store.find('user', 1) * }).then(function (user) { * // not only was a &quot;user&quot; record retrieved, but it was added to the * // store's &quot;user&quot; collection * const cachedUser = store.getCollection('user').get(1) * user === cachedUser // true * }) * * @class DataStore * @extends Container * @param {Object} [opts] Configuration options. See {@link Container}. * @return {DataStore} */ const DataStore = Container.extend({ constructor (opts) { const self = this classCallCheck(self, DataStore) getSuper(self).call(self, opts) self.CollectionClass = self.CollectionClass || LinkedCollection self._collections = {} fillIn(self, DATASTORE_DEFAULTS) return self }, /** * TODO * * @name DataStore#_end * @method * @private * @param {string} name Name of the {@link LinkedCollection} to which to * add the data. * @param {Object} data TODO. * @param {Object} [opts] Configuration options. * @return {(Object|Array)} Result. */ _end (name, data, opts) { if (opts.raw) { data.data = this.getCollection(name).add(data.data, opts) return data } else { data = this.getCollection(name).add(data, opts) } return data }, /** * TODO * * @name DataStore#create * @method * @param {string} name Name of the {@link Mapper} to target. * @param {Object} record Passed to {@link Mapper#create}. * @param {Object} [opts] Passed to {@link Mapper#create}. See * {@link Mapper#create} for more configuration options. * @return {Promise} */ create (name, record, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).create(record, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#createMany * @method * @param {string} name Name of the {@link Mapper} to target. * @param {Array} records Passed to {@link Mapper#createMany}. * @param {Object} [opts] Passed to {@link Mapper#createMany}. See * {@link Mapper#createMany} for more configuration options. * @return {Promise} */ createMany (name, records, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).createMany(records, opts).then(function (data) { return self._end(name, data, opts) }) }, defineMapper (name, opts) { const self = this const mapper = getSuper(self).prototype.defineMapper.call(self, name, opts) mapper.relationList = mapper.relationList || [] mapper.relationList.forEach(function (def) { // TODO: Conditionally add getters and setters to RecordClass prototype }) // The datastore uses a subclass of Collection that is &quot;datastore-aware&quot; const collection = self._collections[name] = new self.CollectionClass(null, { // Make sure the collection has somewhere to store &quot;added&quot; timestamps _added: {}, // Give the collection a reference to this datastore datastore: self, // The mapper tied to the collection mapper }) // Create a secondary index on the &quot;added&quot; timestamps of records in the // collection collection.createIndex('addedTimestamps', ['$'], { fieldGetter (obj) { return collection._added[collection.recordId(obj)] } }) return mapper }, /** * TODO * * @name DataStore#destroy * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#destroy}. * @param {Object} [opts] - Passed to {@link Mapper#destroy}. See * {@link Mapper#destroy} for more configuration options. * @return {Promise} */ destroy (name, id, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).destroy(id, opts).then(function (data) { if (opts.raw) { data.data = self.getCollection(name).remove(id, opts) } else { data = self.getCollection(name).remove(id, opts) } return data }) }, /** * TODO * * @name Mapper#destroyAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object} [query] - Passed to {@link Mapper#destroyAll}. * @param {Object} [opts] - Passed to {@link Mapper#destroyAll}. See * {@link Mapper#destroyAll} for more configuration options. * @return {Promise} */ destroyAll (name, query, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).destroyAll(query, opts).then(function (data) { if (opts.raw) { data.data = self.getCollection(name).removeAll(query, opts) } else { data = self.getCollection(name).removeAll(query, opts) } return data }) }, /** * TODO * * @name DataStore#find * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#find}. * @param {Object} [opts] - Passed to {@link Mapper#find}. * @return {Promise} */ find (name, id, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).find(id, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#findAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object} [query] - Passed to {@link Model.findAll}. * @param {Object} [opts] - Passed to {@link Model.findAll}. * @return {Promise} */ findAll (name, query, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).findAll(query, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#getCollection * @method * @param {string} name Name of the {@link DataStoreCollection} to retrieve. * @return {DataStoreCollection} */ getCollection (name) { const collection = this._collections[name] if (!collection) { throw new ReferenceError(`${name} is not a registered collection!`) } return collection }, /** * TODO * * @name DataStore#update * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#update}. * @param {Object} record - Passed to {@link Mapper#update}. * @param {Object} [opts] - Passed to {@link Mapper#update}. See * {@link Mapper#update} for more configuration options. * @return {Promise} */ update (name, id, record, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).update(id, record, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#updateAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object?} query - Passed to {@link Model.updateAll}. * @param {Object} props - Passed to {@link Model.updateAll}. * @param {Object} [opts] - Passed to {@link Model.updateAll}. See * {@link Model.updateAll} for more configuration options. * @return {Promise} */ updateAll (name, query, props, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).updateAll(query, props, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#updateMany * @method * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records Passed to {@link Mapper#updateMany}. * @param {Object} [opts] Passed to {@link Mapper#updateMany}. See * {@link Mapper#updateMany} for more configuration options. * @return {Promise} */ updateMany (name, records, opts) { const self = this opts || (opts = {}) fillIn(opts, self.modelOpts) return self.getMapper(name).updateMany(records, opts).then(function (data) { return self._end(name, data, opts) }) } }) DataStore.prototype.defineResource = DataStore.prototype.defineMapper /** * Create a DataStore subclass. * * ```javascript * var MyDataStore = DataStore.extend({ * foo: function () { return 'bar' } * }) * var store = new MyDataStore() * store.foo() // &quot;bar&quot; * ``` * * @name DataStore.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of DataStore. */ DataStore.extend = extend export { DataStore as default } × Search results Close Back to js-data.io "},"LinkedCollection.js.html":{"id":"LinkedCollection.js.html","title":"Source: LinkedCollection.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: LinkedCollection.js import { classCallCheck, extend, get, getSuper, isArray, isObject, set } from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import Collection from './Collection' /** * TODO * * ```javascript * import {LinkedCollection} from 'js-data' * ``` * * @class LinkedCollection * @extends Collection * @param {Array} [records] Initial set of records to insert into the * collection. See {@link Collection}. * @param {Object} [opts] Configuration options. See {@link Collection}. * @return {Mapper} */ const LinkedCollection = Collection.extend({ constructor (records, opts) { const self = this classCallCheck(self, LinkedCollection) getSuper(self).call(self, records, opts) // Make sure this collection has somewhere to store &quot;added&quot; timestamps self._added = {} // Make sure this collection a reference to a datastore if (!self.datastore) { throw new Error('This collection must have a datastore!') } return self }, add (records, opts) { // console.log('add', this.mapper.name, records) const self = this const datastore = self.datastore const mapper = self.mapper const relationList = mapper.relationList || [] const timestamp = new Date().getTime() let singular records = getSuper(self).prototype.add.call(self, records, opts) if (isObject(records) &amp;&amp; !isArray(records)) { singular = true records = [records] } records.forEach(function (record) { // Track when this record was added self._added[self.recordId(record)] = timestamp }) if (relationList.length &amp;&amp; records.length) { // Check the currently visited record for relations that need to be // inserted into their respective collections. mapper.relationList.forEach(function (def) { if (def.add === false) { return } const relationName = def.relation // A reference to the Mapper that this Mapper is related to const Relation = datastore.getMapper(relationName) // The field used by the related Mapper as the primary key const relationIdAttribute = Relation.idAttribute // Grab the foreign key in this relationship, if there is one const foreignKey = def.foreignKey const localField = def.localField // A lot of this is an optimization for being able to insert a lot of // data as quickly as possible const relatedCollection = datastore.getCollection(relationName) const type = def.type const isBelongsTo = type === belongsToType const isHasMany = type === hasManyType const isHasOne = type === hasOneType let relatedData records.forEach(function (record) { // Grab a reference to the related data attached or linked to the // currently visited record relatedData = get(record, localField) if (relatedData) { const id = get(record, mapper.idAttribute) // Otherwise, if there is something to be added, add it if (isHasMany) { // Handle inserting hasMany relations relatedData = relatedData.map(function (toInsertItem) { // Check that this item isn't the same item that is already in the // store if (toInsertItem !== relatedCollection.get(get(toInsertItem, relationIdAttribute))) { // Make sure this item has its foreignKey if (foreignKey) { set(toInsertItem, foreignKey, id) } // Finally add this related item toInsertItem = relatedCollection.add(toInsertItem) } return toInsertItem }) // If it's the parent that has the localKeys if (def.localKeys) { set(record, def.localKeys, relatedData.map(function (inserted) { return get(inserted, relationIdAttribute) })) } } else { const relatedDataId = get(relatedData, relationIdAttribute) // Handle inserting belongsTo and hasOne relations if (relatedData !== relatedCollection.get(relatedDataId)) { // Make sure foreignKey field is set if (isBelongsTo) { set(record, def.foreignKey, relatedDataId) } else if (isHasOne) { set(relatedData, def.foreignKey, id) } // Finally insert this related item relatedData = relatedCollection.add(relatedData) } } set(record, localField, relatedData) } }) }) } return singular ? records[0] : records }, remove (id, opts) { const self = this delete self._added[id] return getSuper(self).prototype.remove.call(self, id, opts) }, removeAll (query, opts) { const self = this const records = getSuper(self).prototype.removeAll.call(self, query, opts) records.forEach(function (record) { delete self._added[self.recordId(record)] }) return records } }) /** * Create a LinkedCollection subclass. * * ```javascript * var MyLinkedCollection = LinkedCollection.extend({ * foo: function () { return 'bar' } * }) * var collection = new MyLinkedCollection() * collection.foo() // &quot;bar&quot; * ``` * * @name LinkedCollection.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of LinkedCollection. */ LinkedCollection.extend = extend export { LinkedCollection as default } × Search results Close Back to js-data.io "},"Mapper.js.html":{"id":"Mapper.js.html","title":"Source: Mapper.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Mapper.js import * as utils from './utils' import { belongsTo, hasMany, hasOne } from './decorators' import Record from './Record' import Schema from './Schema' const { resolve } = utils const notify = function (...args) { const self = this const opts = args.pop() self.dbg(opts.op, ...args) if (opts.notify || (opts.notify === undefined &amp;&amp; self.notify)) { setTimeout(() =&gt; { self.emit(opts.op, ...args) }) } } const MAPPER_DEFAULTS = { /** * Hash of registered adapters. Don't modify. Use {@link Mapper#registerAdapter}. * * @name Mapper#_adapters * @private */ _adapters: null, /** * Hash of registered listeners. Don't modify. Use {@link Mapper#on} and * {@link Mapper#off}. * * @name Mapper#_listeners * @private */ _listeners: null, /** * The name of the registered adapter that this Mapper should used by default. * * @name Mapper#defaultAdapter * @type {string} * @default &quot;http&quot; */ defaultAdapter: 'http', /** * Whether to enable debug-level logs. * * @name Mapper#debug * @type {boolean} * @default false */ debug: false, /** * The field used as the unique identifier on records handled by this Mapper. * * @name Mapper#idAttribute * @type {string} * @default id */ idAttribute: 'id', /** * Minimum amount of meta information required to start operating against a * resource. * * @name Mapper#name * @type {string} */ name: null, /** * Whether this Mapper should emit operational events. * * @name Mapper#notify * @type {boolean} * @default true */ notify: true, /** * Whether {@link Mapper#create}, {@link Mapper#createMany}, {@link Mapper#save}, * {@link Mapper#update}, {@link Mapper#updateAll}, {@link Mapper#updateMany}, * {@link Mapper#find}, {@link Mapper#findAll}, {@link Mapper#destroy}, and * {@link Mapper#destroyAll} should return a raw result object that contains * both the instance data returned by the adapter _and_ metadata about the * operation. * * The default is to NOT return the result object, and instead return just the * instance data. * * @name Mapper#raw * @type {boolean} * @default false */ raw: false, /** * Set the `false` to force the Mapper to work with POJO objects only. * * ```javascript * import {Mapper, Record} from 'js-data' * const UserMapper = new Mapper({ RecordClass: false }) * UserMapper.RecordClass // false * const user = UserMapper#createRecord() * user instanceof Record // false * ``` * * Set to a custom class to have records wrapped in your custom class. * * ```javascript * import {Mapper, Record} from 'js-data' * // Custom class * class User { * constructor (props = {}) { * for (var key in props) { * if (props.hasOwnProperty(key)) { * this[key] = props[key] * } * } * } * } * const UserMapper = new Mapper({ RecordClass: User }) * UserMapper.RecordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // false * user instanceof User // true * ``` * * Extend the {@link Record} class. * * ```javascript * import {Mapper, Record} from 'js-data' * // Custom class * class User extends Record { * constructor () { * super(props) * } * } * const UserMapper = new Mapper({ RecordClass: User }) * UserMapper.RecordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // true * user instanceof User // true * ``` * * @name Mapper#RecordClass * @default {@link Record} */ RecordClass: undefined, schema: null, /** * Whether {@link Mapper#create} and {@link Mapper#createMany} should instead * call {@link Mapper#update} and {@link Mapper#updateMany} if the provided * record(s) already contain a primary key. * * @name Mapper#upsert * @type {boolean} * @default true */ upsert: true } /** * ```javascript * import {Mapper} from 'js-data' * ``` * * The core of JSData's [ORM/ODM][orm] implementation. Given a minimum amout of * meta information about a resource, a Mapper can perform generic CRUD * operations against that resource. Apart from its configuration, a Mapper is * stateless. The particulars of various persistence layers has been abstracted * into adapters, which a Mapper uses to perform its operations. * * The term &quot;Mapper&quot; comes from the [Data Mapper Pattern][pattern] described in * Martin Fowler's [Patterns of Enterprise Application Architecture][book]. A * Data Mapper moves data between [in-memory object instances][record] and a * relational or document-based database. JSData's Mapper can work with any * persistence layer you can write an adapter for. * * _(&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation * to prevent confusion.)_ * * [orm]: https://en.wikipedia.org/wiki/Object-relational_mapping * [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern * [book]: http://martinfowler.com/books/eaa.html * [record]: Record.html * * @class Mapper * @param {Object} [opts] Configuration options. */ export default function Mapper (opts) { const self = this utils.classCallCheck(self, Mapper) opts || (opts = {}) utils.fillIn(self, opts) utils.fillIn(self, utils.copy(MAPPER_DEFAULTS)) if (!self.name) { throw new Error('mapper cannot function without a name!') } self._adapters || (self._adapters = {}) self._listeners || (self._listeners = {}) if (!(self.schema instanceof Schema)) { self.schema = new Schema(self.schema || {}) } if (utils.isUndefined(self.RecordClass)) { self.RecordClass = Record.extend() } if (self.RecordClass) { self.RecordClass.Mapper = self } } /** * Instance members */ utils.addHiddenPropsToTarget(Mapper.prototype, { /** * TODO * * @name Mapper#end * @method */ end (data, opts) { const self = this if (opts.raw) { utils._(opts, data) } let _data = opts.raw ? data.data : data if (utils.isArray(_data)) { _data = _data.map(function (item) { return self.createRecord(item) }) } else { _data = self.createRecord(_data) } if (opts.raw) { data.data = _data } else { data = _data } if (opts.notify) { setTimeout(function () { self.emit(opts.op, data, opts) }) } return data }, /** * Create an unsaved, uncached instance of this Mapper's * {@link Mapper#RecordClass}. * * Returns `props` if `props` is already an instance of * {@link Mapper#RecordClass}. * * @name Mapper#createRecord * @method * @param {Object} props The initial properties of the new unsaved record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation on the * initial properties. * @return {Object} The unsaved record. */ createRecord (props, opts) { const RecordClass = this.RecordClass // Check to make sure &quot;props&quot; is not already an instance of this Mapper. return RecordClass ? (props instanceof RecordClass ? props : new RecordClass(props, opts)) : props }, /** * Return whether `record` is an instance of this Mappers's RecordClass. * * @name Mapper#is * @method * @param {Object} record The record to check. * @return {boolean} Whether `record` is an instance of this Mappers's * {@ link Mapper#RecordClass}. */ is (record) { const RecordClass = this.RecordClass return RecordClass ? record instanceof RecordClass : false }, /** * Return a plain object representation of the given record. * * @name Mapper#toJSON * @method * @param {Object} record Record from which to create a plain object * representation. * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. * @return {Object} Plain object representation of the record. */ toJSON (record, opts) { const self = this opts || (opts = {}) let json = record if (self.is(record)) { json = utils.copy(record) // The user wants to include relations in the resulting plain object // representation if (self &amp;&amp; self.relationList &amp;&amp; opts.with) { if (utils.isString(opts.with)) { opts.with = [opts.with] } self.relationList.forEach(def =&gt; { let containedName if (opts.with.indexOf(def.relation) !== -1) { containedName = def.relation } else if (opts.with.indexOf(def.localField) !== -1) { containedName = def.localField } if (containedName) { const optsCopy = { with: opts.with.slice() } // Prepare to recurse into deeply nested relations optsCopy.with.splice(optsCopy.with.indexOf(containedName), 1) optsCopy.with.forEach((relation, i) =&gt; { if (relation &amp;&amp; relation.indexOf(containedName) === 0 &amp;&amp; relation.length &gt;= containedName.length &amp;&amp; relation[containedName.length] === '.') { optsCopy.with[i] = relation.substr(containedName.length + 1) } else { optsCopy.with[i] = '' } }) const relationData = utils.get(record, def.localField) if (relationData) { // The actual recursion if (utils.isArray(relationData)) { utils.set(json, def.localField, relationData.map(item =&gt; def.getRelation().toJSON(item, optsCopy))) } else { utils.set(json, def.localField, def.getRelation().toJSON(relationData, optsCopy)) } } } }) } } return json }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @name Mapper#getAdapter * @method * @param {string} [name] The name of the adapter to retrieve. * @return {Adapter} The adapter. */ getAdapter (name) { const self = this self.dbg('getAdapter', 'name:', name) const adapter = self.getAdapterName(name) if (!adapter) { throw new ReferenceError(`${adapter} not found!`) } return self.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @name Mapper#getAdapterName * @method * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @return {string} The name of the adapter. */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || opts.defaultAdapter }, /** * @name Mapper#getAdapters * @method */ getAdapters () { return this._adapters }, getSchema () { return this.schema }, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeCreate * @method * @param {Object} props The `props` argument passed to {@link Mapper#create}. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. */ beforeCreate: notify, checkUpsertCreate (props, opts) { const self = this return (opts.upsert || (opts.upsert === undefined &amp;&amp; self.upsert)) &amp;&amp; utils.get(props, self.idAttribute) }, /** * Create and save a new the record using the provided `props`. * * {@link Mapper#beforeCreate} will be called before calling the adapter. * {@link Mapper#afterCreate} will be called after calling the adapter. * * @name Mapper#create * @method * @param {Object} props The properties for the new record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * created data. If `true` return a response object that includes the created * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `props` contains nested relations. NOT performed in a transaction. * @return {Promise} */ create (props, opts) { let op, adapter const self = this // Default values for arguments props || (props = {}) opts || (opts = {}) // Check whether we should do an upsert instead if (self.checkUpsertCreate(props, opts)) { return self.update(utils.get(props, self.idAttribute), props, opts) } // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return resolve(self[op](props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = _props || props // Now delegate to the adapter op = opts.op = 'create' const json = self.toJSON(props, opts) self.dbg(op, json, opts) return resolve(self.getAdapter(adapter)[op](self, json, opts)) }).then(function (data) { // afterCreate lifecycle hook op = opts.op = 'afterCreate' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @name Mapper#afterCreate * @method * @param {Object} data The `data` return by the adapter. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. */ afterCreate: notify, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeCreateMany * @method * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. */ beforeCreateMany: notify, checkUpsertCreateMany (records, opts) { const self = this if (opts.upsert || (opts.upsert === undefined &amp;&amp; self.upsert)) { return records.reduce(function (hasId, item) { return hasId &amp;&amp; utils.get(item, self.idAttribute) }, true) } }, /** * Given an array of records, batch create them via an adapter. * * {@link Mapper#beforeCreateMany} will be called before calling the adapter. * {@link Mapper#afterCreateMany} will be called after calling the adapter. * * @name Mapper#createMany * @method * @param {Array} records Array of records to be created in one batch. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * updated data. If `true` return a response object that includes the updated * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to create in a cascading create * if the records to be created have linked/nested relations. NOT performed * in a transaction. * @return {Promise} */ createMany (records, opts) { let op, adapter const self = this // Default values for arguments records || (records = []) opts || (opts = {}) // Check whether we should do an upsert instead if (self.checkUpsertCreateMany(records, opts)) { return self.updateMany(records, opts) } // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return resolve(self[op](records, opts)) .then(function (_records) { // Allow for re-assignment from lifecycle hook records = _records || records // Now delegate to the adapter op = opts.op = 'createMany' const json = records.map(function (item) { return self.toJSON(item, opts) }) self.dbg(op, json, opts) return resolve(self.getAdapter(adapter)[op](self, json, opts)) }).then(function (data) { // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @name Mapper#afterCreateMany * @method * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. */ afterCreateMany: notify, /** * Mappers lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeFind * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. */ beforeFind: notify, /** * Retrieve via an adapter the record with the given primary key. * * {@link Mapper#beforeFind} will be called before calling the adapter. * {@link Mapper#afterFind} will be called after calling the adapter. * * @name Mapper#find * @method * @param {(string|number)} id The primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * updated data. If `true` return a response object that includes the updated * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @return {Promise} */ find (id, opts) { let op, adapter const self = this // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Mappers's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeFind lifecycle hook op = opts.op = 'beforeFind' return resolve(self[op](id, opts)).then(function (_id) { // Allow for re-assignment from lifecycle hook id = _id === undefined ? id : _id // Now delegate to the adapter op = opts.op = 'find' self.dbg(op, id, opts) return resolve(self.getAdapter(adapter)[op](self, id, opts)) }).then(function (data) { // afterFind lifecycle hook op = opts.op = 'afterFind' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @name Mapper#afterFind * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. */ afterFind: notify, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeFindAll * @method * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. */ beforeFindAll: notify, /** * Using the `query` argument, select records to pull from an adapter. * Expects back from the adapter the array of selected records. * * {@link Mapper#beforeFindAll} will be called before calling the adapter. * {@link Mapper#afterFindAll} will be called after calling the adapter. * * @name Mapper#findAll * @method * @param {Object} [query={}] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {number} [query.skip] Number to skip. * @param {number} [query.limit] Number to limit to. * @param {Array} [query.orderBy] Sorting criteria. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * resulting data. If `true` return a response object that includes the * resulting data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @return {Promise} */ findAll (query, opts) { let op, adapter const self = this // Default values for arguments query || (query = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeFindAll lifecycle hook op = opts.op = 'beforeFindAll' return resolve(self[op](query, opts)).then(function (_query) { // Allow for re-assignment from lifecycle hook query = _query || query // Now delegate to the adapter op = opts.op = 'findAll' self.dbg(op, query, opts) return resolve(self.getAdapter(adapter)[op](self, query, opts)) }).then(function (data) { // afterFindAll lifecycle hook op = opts.op = 'afterFindAll' return resolve(self[op](data, query, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @name Mapper#afterFindAll * @method * @param {Object} data The `data` returned by the adapter. * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. */ afterFindAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeUpdate * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. */ beforeUpdate: notify, /** * Using an adapter, update the record with the primary key specified by the * `id` argument. * * {@link Mapper#beforeUpdate} will be called before updating the record. * {@link Mapper#afterUpdate} will be called after updating the record. * * @name Mapper#update * @method * @param {(string|number)} id The primary key of the record to update. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * updated data. If `true` return a response object that includes the updated * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to update in a cascading * update if `props` contains nested updates to relations. NOT performed in a * transaction. * @return {Promise} */ update (id, props, opts) { let op, adapter const self = this // Default values for arguments props || (props = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeUpdate lifecycle hook op = opts.op = 'beforeUpdate' return resolve(self[op](id, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = _props || props // Now delegate to the adapter op = opts.op = 'update' const json = self.toJSON(props, opts) self.dbg(op, id, json, opts) return resolve(self.getAdapter(adapter)[op](self, id, json, opts)) }).then(function (data) { // afterUpdate lifecycle hook op = opts.op = 'afterUpdate' return resolve(self[op](id, data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @name Mapper#afterUpdate * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. */ afterUpdate: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeUpdateMany * @method * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. */ beforeUpdateMany: notify, /** * Given an array of updates, perform each of the updates via an adapter. Each * &quot;update&quot; is a hash of properties with which to update an record. Each * update must contain the primary key to be updated. * * {@link Mapper#beforeUpdateMany} will be called before making the update. * {@link Mapper#afterUpdateMany} will be called after making the update. * * @name Mapper#updateMany * @method * @param {Array} records Array up record updates. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * updated data. If `true` return a response object that includes the updated * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to update in a cascading * update if each record update contains nested updates for relations. NOT * performed in a transaction. * @return {Promise} */ updateMany (records, opts) { let op, adapter const self = this // Default values for arguments records || (records = []) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeUpdateMany lifecycle hook op = opts.op = 'beforeUpdateMany' return resolve(self[op](records, opts)).then(function (_records) { // Allow for re-assignment from lifecycle hook records = _records || records // Now delegate to the adapter op = opts.op = 'updateMany' const json = records.map(function (item) { return self.toJSON(item, opts) }) self.dbg(op, json, opts) return resolve(self.getAdapter(adapter)[op](self, json, opts)) }).then(function (data) { // afterUpdateMany lifecycle hook op = opts.op = 'afterUpdateMany' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @name Mapper#afterUpdateMany * @method * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. */ afterUpdateMany: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeUpdateAll * @method * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. */ beforeUpdateAll: notify, /** * Using the `query` argument, perform the a single updated to the selected * records. Expects back from the adapter an array of the updated records. * * {@link Mapper#beforeUpdateAll} will be called before making the update. * {@link Mapper#afterUpdateAll} will be called after making the update. * * @name Mapper#updateAll * @method * @param {Object} [query={}] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {number} [query.skip] Number to skip. * @param {number} [query.limit] Number to limit to. * @param {Array} [query.orderBy] Sorting criteria. * @param {Object} props Update to apply to selected records. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * updated data. If `true` return a response object that includes the updated * data and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to update in a cascading * update if `props` contains nested updates to relations. NOT performed in a * transaction. * @return {Promise} */ updateAll (query, props, opts) { let op, adapter const self = this // Default values for arguments query || (query = {}) props || (props = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeUpdateAll lifecycle hook op = opts.op = 'beforeUpdateAll' return resolve(self[op](query, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = _props || props // Now delegate to the adapter op = opts.op = 'updateAll' const json = self.toJSON(props, opts) self.dbg(op, query, json, opts) return resolve(self.getAdapter(adapter)[op](self, query, json, opts)) }).then(function (data) { // afterUpdateAll lifecycle hook op = opts.op = 'afterUpdateAll' return resolve(self[op](query, data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data // Possibly inject result and/or formulate result object return self.end(data, opts) }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @name Mapper#afterUpdateAll * @method * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. */ afterUpdateAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeDestroy * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. */ beforeDestroy: notify, /** * Using an adapter, destroy the record with the primary key specified by the * `id` argument. * * {@link Mapper#beforeDestroy} will be called before destroying the record. * {@link Mapper#afterDestroy} will be called after destroying the record. * * @name Mapper#destroy * @method * @param {(string|number)} id The primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * ejected data (if any). If `true` return a response object that includes the * ejected data (if any) and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to destroy in a cascading * delete. NOT performed in a transaction. * @return {Promise} */ destroy (id, opts) { let op, adapter const self = this // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeDestroy lifecycle hook op = opts.op = 'beforeDestroy' return resolve(self[op](id, opts)).then(function (_id) { // Allow for re-assignment from lifecycle hook id = _id === undefined ? id : _id // Now delegate to the adapter op = opts.op = 'destroy' self.dbg(op, id, opts) return resolve(self.getAdapter(adapter)[op](self, id, opts)) }).then(function (data) { // afterDestroy lifecycle hook op = opts.op = 'afterDestroy' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data if (opts.raw) { utils._(opts, data) return data } return data }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @name Mapper#afterDestroy * @method * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. */ afterDestroy: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @name Mapper#beforeDestroyAll * @method * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. */ beforeDestroyAll: notify, /** * Using the `query` argument, destroy the selected records via an adapter. * If no `query` is provided then all records will be destroyed. * * {@link Mapper#beforeDestroyAll} will be called before destroying the records. * {@link Mapper#afterDestroyAll} will be called after destroying the records. * * @name Mapper#destroyAll * @method * @param {Object} [query={}] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {number} [query.skip] Number to skip. * @param {number} [query.limit] Number to limit to. * @param {Array} [query.orderBy] Sorting criteria. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] Whether to emit * lifecycle events. * @param {boolean} [opts.raw={@link Mapper#raw}] If `false`, return the * ejected data (if any). If `true` return a response object that includes the * ejected data (if any) and metadata about the operation. * @param {string[]} [opts.with=[]] Relations to destroy in a cascading * delete. NOT performed in a transaction. * @return {Promise} */ destroyAll (query, opts) { let op, adapter const self = this // Default values for arguments query || (query = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeDestroyAll lifecycle hook op = opts.op = 'beforeDestroyAll' return resolve(self[op](query, opts)).then(function (_query) { // Allow for re-assignment from lifecycle hook query = _query || query // Now delegate to the adapter op = opts.op = 'destroyAll' self.dbg(op, query, opts) return resolve(self.getAdapter(adapter)[op](self, query, opts)) }).then(function (data) { // afterDestroyAll lifecycle hook op = opts.op = 'afterDestroyAll' return resolve(self[op](data, query, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data if (opts.raw) { utils._(opts, data) return data } return data }) }) }, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @name Mapper#afterDestroyAll * @method * @param {*} data The `data` returned by the adapter. * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. */ afterDestroyAll: notify, /** * @name Mapper#log * @method */ log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (${this.name || 'mapper'})` if (console[level]) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } }, /** * @name Mapper#dbg * @method */ dbg (...args) { this.log('debug', ...args) }, /** * Usage: * * Post.belongsTo(User, { * localKey: 'myUserId' * }) * * Comment.belongsTo(User) * Comment.belongsTo(Post, { * localField: '_post' * }) * * @name Mapper#belongsTo * @method */ belongsTo (RelatedMapper, opts) { return belongsTo(RelatedMapper, opts)(this) }, /** * Usage: * * User.hasMany(Post, { * localField: 'my_posts' * }) * * @name Mapper#hasMany * @method */ hasMany (RelatedMapper, opts) { return hasMany(RelatedMapper, opts)(this) }, /** * Usage: * * User.hasOne(Profile, { * localField: '_profile' * }) * * @name Mapper#hasOne * @method */ hasOne (RelatedMapper, opts) { return hasOne(RelatedMapper, opts)(this) }, /** * Register an adapter on this mapper under the given name. * * @name Mapper#registerAdapter * @method * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for this Mapper. */ registerAdapter (name, adapter, opts) { const self = this opts || (opts = {}) self.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { self.defaultAdapter = name } } }) /** * Create a Mapper subclass. * * ```javascript * var MyMapper = Mapper.extend({ * foo: function () { return 'bar' } * }) * var mapper = new MyMapper() * mapper.foo() // &quot;bar&quot; * ``` * * @name Mapper.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of Mapper. */ Mapper.extend = utils.extend /** * Register a new event listener on this Mapper. * * @name Mapper#on * @method */ /** * Remove an event listener from this Mapper. * * @name Mapper#off * @method */ /** * Trigger an event on this Mapper. * * @name Mapper#emit * @method * @param {string} event Name of event to emit. */ /** * A Mapper's registered listeners are stored at {@link Mapper#_listeners}. */ utils.eventify( Mapper.prototype, function () { return this._listeners }, function (value) { this._listeners = value } ) × Search results Close Back to js-data.io "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: index.js /** * Registered as `js-data` in NPM and Bower. * #### Script tag * ```js * window.JSData * ``` * #### CommonJS * ```js * var JSData = require('js-data') * ``` * #### ES6 Modules * ```js * import JSData from 'js-data' * ``` * #### AMD * ```js * define('myApp', ['js-data'], function (JSData) { ... }) * ``` * * @module js-data */ /** * Details of the current version of the `js-data` module. * * @name version * @memberof module:js-data * @type {Object} * @property {string} full The full semver value. * @property {number} major The major version number. * @property {number} minor The minor version number. * @property {number} patch The patch version number. * @property {(string|boolean)} alpha The alpha version value, otherwise `false` * if the current version is not alpha. * @property {(string|boolean)} beta The beta version value, otherwise `false` * if the current version is not beta. */ const version = { full: '&lt;%= pkg.version %&gt;', major: parseInt('&lt;%= major %&gt;', 10), minor: parseInt('&lt;%= minor %&gt;', 10), patch: parseInt('&lt;%= patch %&gt;', 10), alpha: '&lt;%= alpha %&gt;' !== 'false' ? '&lt;%= alpha %&gt;' : false, beta: '&lt;%= beta %&gt;' !== 'false' ? '&lt;%= beta %&gt;' : false } /** * {@link Collection} class. * @name module:js-data.Collection */ import Collection from './Collection' /** * {@link Container} class. * @name module:js-data.Container */ import Container from './Container' /** * {@link DataStore} class. * @name module:js-data.DataStore */ import DataStore from './DataStore' /** * {@link LinkedCollection} class. * @name module:js-data.LinkedCollection */ import LinkedCollection from './LinkedCollection' /** * {@link Mapper} class. * @name module:js-data.Mapper */ import Mapper from './Mapper' /** * {@link Query} class. * @name module:js-data.Query */ import Query from './Query' /** * {@link Record} class. * @name module:js-data.Record */ import Record from './Record' /** * {@link Schema} class. * @name module:js-data.Schema */ import Schema from './Schema' import * as utils from './utils' export * from './decorators' const DS = DataStore export { Collection, Container, DataStore, DS, // Backwards compatiblity LinkedCollection, Mapper, Query, Record, Schema, utils, version } × Search results Close Back to js-data.io "},"decorators.js.html":{"id":"decorators.js.html","title":"Source: decorators.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: decorators.js import { fillIn, isFunction, isString } from './utils' export const belongsToType = 'belongsTo' export const hasManyType = 'hasMany' export const hasOneType = 'hasOne' function Relation (related, opts) { const self = this opts || (opts = {}) const localField = opts.localField if (!localField) { throw new Error('localField is required') } const foreignKey = opts.foreignKey || opts.localKey if (!foreignKey &amp;&amp; (opts.type === belongsToType || opts.type === hasOneType)) { throw new Error('foreignKey is required') } const localKeys = opts.localKeys const foreignKeys = opts.foreignKeys if (!foreignKey &amp;&amp; !localKeys &amp;&amp; !foreignKeys &amp;&amp; opts.type === hasManyType) { throw new Error('one of (foreignKey, localKeys, foreignKeys) is required') } if (isString(related)) { opts.relation = related } else if (related) { opts.relation = related.name } if (!related || (isString(related) &amp;&amp; !isFunction(opts.getRelation))) { throw new Error('you must provide a reference to the related mapper!') } fillIn(self, opts) } const relatedTo = function (mapper, related, opts) { opts || (opts = {}) if (!opts.type) { throw new Error('must specify relation type!') } opts.mapper = mapper opts.name = mapper.name const relation = new Relation(related, opts) mapper.relationList || (mapper.relationList = []) mapper.relationFields || (mapper.relationFields = []) mapper.relationList.push(relation) mapper.relationFields.push(relation.localField) } /** * TODO * * @name module:js-data.belongsTo * @method * @param {Mapper} related The relation the target belongs to. * @param {Object} opts Configuration options. * @param {string} opts.foreignKey The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @return {Function} Invocation function, which accepts the target as the only * parameter. */ export const belongsTo = function (related, opts) { opts || (opts = {}) opts.type = belongsToType return function (target) { relatedTo(target, related, opts) } } /** * TODO * * @name module:js-data.hasMany * @method * @param {Mapper} related The relation of which the target has many. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @return {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasMany = function (related, opts) { opts || (opts = {}) opts.type = hasManyType return function (target) { relatedTo(target, related, opts) } } /** * TODO * * @name module:js-data.hasOne * @method * @param {Mapper} related The relation of which the target has one. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @return {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasOne = function (related, opts) { opts || (opts = {}) opts.type = hasOneType return function (target) { relatedTo(target, related, opts) } } × Search results Close Back to js-data.io "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: utils.js /** * @name utils * @memberof module:js-data * @type {Object} * @property {Function} addHiddenPropsToTarget TODO * @property {Function} classCallCheck TODO * @property {Function} copy TODO * @property {Function} deepMixIn TODO * @property {Function} eventify TODO * @property {Function} extend TODO * @property {Function} fillIn TODO * @property {Function} fromJson TODO * @property {Function} get TODO * @property {Function} getSuper TODO * @property {Function} intersection TODO * @property {Function} isArray TODO * @property {Function} isBlacklisted TODO * @property {boolean} isBrowser TODO * @property {Function} isBoolean TODO * @property {Function} isFunction TODO * @property {Function} isInteger TODO * @property {Function} isNull TODO * @property {Function} isNumber TODO * @property {Function} isObject TODO * @property {Function} isRegExp TODO * @property {Function} isSorN TODO * @property {Function} isString TODO * @property {Function} isUndefined TODO * @property {Function} possibleConstructorReturn TODO * @property {Function} reject TODO * @property {Function} resolve TODO * @property {Function} set TODO * @property {Function} toJson TODO * @property {Function} uuid TODO */ const INFINITY = 1 / 0 const MAX_INTEGER = 1.7976931348623157e+308 const BOOL_TAG = '[object Boolean]' const DATE_TAG = '[object Date]' const FUNC_TAG = '[object Function]' const NUMBER_TAG = '[object Number]' const OBJECT_TAG = '[object Object]' const REGEXP_TAG = '[object RegExp]' const STRING_TAG = '[object String]' const objToString = Object.prototype.toString let isBrowser // Attempt to detect whether we are in the browser. try { isBrowser = !!window } catch (e) { isBrowser = false } export {isBrowser} const toString = function (value) { return objToString.call(value) } const toInteger = function (value) { if (!value) { return value === 0 ? value : 0 } value = +value if (value === INFINITY || value === -INFINITY) { const sign = (value &lt; 0 ? -1 : 1) return sign * MAX_INTEGER } const remainder = value % 1 return value === value ? (remainder ? value - remainder : value) : 0 // eslint-disable-line } const isPlainObject = function (value) { return (!!value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === Object) } export const isArray = Array.isArray export const isDate = function (value) { return (value &amp;&amp; typeof value === 'object' &amp;&amp; toString(value) === DATE_TAG) } export const isFunction = function (value) { return typeof value === 'function' || (value &amp;&amp; toString(value) === FUNC_TAG) } export const isInteger = function (value) { return toString(value) === NUMBER_TAG &amp;&amp; value == toInteger(value) // eslint-disable-line } export const isNull = function (value) { return value === null } export const isNumber = function (value) { const type = typeof value return type === 'number' || (value &amp;&amp; type === 'object' &amp;&amp; toString(value) === NUMBER_TAG) } export const isObject = function (value) { return toString(value) === OBJECT_TAG } export const isRegExp = function (value) { return toString(value) === REGEXP_TAG } export const isSorN = function (value) { return isString(value) || isNumber(value) } export const isString = function (value) { return typeof value === 'string' || (value &amp;&amp; typeof value === 'object' &amp;&amp; toString(value) === STRING_TAG) } export const isUndefined = function (value) { return value === undefined } export const isBoolean = function (value) { return toString(value) === BOOL_TAG } export const get = function (object, prop) { if (!prop) { return } const parts = prop.split('.') const last = parts.pop() while (prop = parts.shift()) { // eslint-disable-line object = object[prop] if (object == null) return } return object[last] } const mkdirP = function (object, path) { if (!path) { return object } const parts = path.split('.') parts.forEach(function (key) { if (!object[key]) { object[key] = {} } object = object[key] }) return object } const PATH = /^(.+)\\.(.+)$/ /** * Set the value at the provided key or path. * * @ignore * @param {Object} object The object on which to set a property. * @param {(string|Object)} path The key or path to the property. Can also * pass in an object of path/value pairs, which will all be set on the target * object. * @param {*} [value] The value to set. */ export const set = function (object, path, value) { if (isObject(path)) { forOwn(path, function (value, _path) { set(object, _path, value) }) } else { const parts = PATH.exec(path) if (parts) { mkdirP(object, parts[1])[parts[2]] = value } else { object[path] = value } } } /** * Iterate over an object's own enumerable properties. * * @ignore * @param {Object} object The object whose properties are to be enumerated. * @param {Function} fn Iteration function. * @param {Object} [thisArg] Content to which to bind `fn`. */ export const forOwn = function (obj, fn, thisArg) { const keys = Object.keys(obj) const len = keys.length let i for (i = 0; i &lt; len; i++) { fn.call(thisArg, obj[keys[i]], keys[i], obj) } } /** * Recursively shallow copy own enumberable properties from `source` to `dest`. * * @ignore * @param {Object} dest The destination object. * @param {Object} source The source object. */ export const deepMixIn = function (dest, source) { if (source) { forOwn(source, function (value, key) { const existing = this[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { deepMixIn(existing, value) } else { this[key] = value } }, dest) } return dest } /** * Proxy for `Promise.resolve`. * * @ignore * @param {*} [value] Value with which to resolve the Promise. * @return {Promise} Promise resolved with `value`. */ export const resolve = function (value) { return Promise.resolve(value) } /** * Proxy for `Promise.reject`. * * @ignore * @param {*} [value] Value with which to reject the Promise. * @return {Promise} Promise reject with `value`. */ export const reject = function (value) { return Promise.reject(value) } /** * Shallow copy properties from src to dest that meet the following criteria: * - own enumerable * - not a function * - does not start with &quot;_&quot; * * @ignore * @param {Object} dest Destination object. * @param {Object} src Source object. */ export const _ = function (dest, src) { for (var key in dest) { let value = dest[key] if (src[key] === undefined &amp;&amp; !isFunction(value) &amp;&amp; key &amp;&amp; key.indexOf('_') !== 0) { src[key] = value } } } /** * Return the intersection of two arrays. * * @ignore * @param {Array} array1 First array. * @param {Array} array2 Second array. * @return {Array} Array of elements common to both arrays. */ export const intersection = function (array1, array2) { if (!array1 || !array2) { return [] } const result = [] let item let i const len = array1.length for (i = 0; i &lt; len; i++) { item = array1[i] if (result.indexOf(item) !== -1) { continue } if (array2.indexOf(item) !== -1) { result.push(item) } } return result } /** * Shallow copy own enumerable properties from `src` to `dest` that are on `src` * but are missing from `dest. * * @ignore * @param {Object} dest The destination object. * @param {Object} source The source object. */ export const fillIn = function (dest, src) { forOwn(src, function (value, key) { if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) } /** * Return whether `prop` is matched by any string or regular expression in `bl`. * * @ignore * @param {string} prop The name of a property. * @param {Array} bl Array of strings and regular expressions. * @return {boolean} Whether `prop` was matched. */ export const isBlacklisted = function (prop, bl) { if (!bl || !bl.length) { return false } let matches for (var i = 0; i &lt; bl.length; i++) { if ((toString(bl[i]) === '[object RegExp]' &amp;&amp; bl[i].test(prop)) || bl[i] === prop) { matches = prop return matches } } return !!matches } /** * Proxy for `JSON.parse`. * * @ignore * @param {string} json JSON to parse. * @return {Object} Parsed object. */ export const fromJson = function (json) { return isString(json) ? JSON.parse(json) : json } /** * Proxy for `JSON.stringify`. * * @ignore * @param {*} value Value to serialize to JSON. * @return {string} JSON string. */ export const toJson = JSON.stringify /** * Deep copy a value. * * @ignore * @param {*} from Value to deep copy. * @return {*} Deep copy of `from`. */ export const copy = function (from, to, stackFrom, stackTo, blacklist) { if (!to) { to = from if (from) { if (isArray(from)) { to = copy(from, [], stackFrom, stackTo, blacklist) } else if (isDate(from)) { to = new Date(from.getTime()) } else if (isRegExp(from)) { to = new RegExp(from.source, from.toString().match(/[^\\/]*$/)[0]) to.lastIndex = from.lastIndex } else if (isObject(from)) { to = copy(from, Object.create(Object.getPrototypeOf(from)), stackFrom, stackTo, blacklist) } } } else { if (from === to) { throw new Error('Cannot copy! Source and destination are identical.') } stackFrom = stackFrom || [] stackTo = stackTo || [] if (isObject(from)) { let index = stackFrom.indexOf(from) if (index !== -1) { return stackTo[index] } stackFrom.push(from) stackTo.push(to) } let result if (isArray(from)) { let i to.length = 0 for (i = 0; i &lt; from.length; i++) { result = copy(from[i], null, stackFrom, stackTo, blacklist) if (isObject(from[i])) { stackFrom.push(from[i]) stackTo.push(result) } to.push(result) } } else { if (isArray(to)) { to.length = 0 } else { forOwn(to, function (value, key) { delete to[key] }) } for (var key in from) { if (from.hasOwnProperty(key)) { if (isBlacklisted(key, blacklist)) { continue } result = copy(from[key], null, stackFrom, stackTo, blacklist) if (isObject(from[key])) { stackFrom.push(from[key]) stackTo.push(result) } to[key] = result } } } } return to } /** * Add eventing capabilities into the target object. * * @ignore * @param {Object} target Target object. * @param {Function} [getter] Custom getter for retrieving the object's event * listeners. * @param {Function} [setter] Custom setter for setting the object's event * listeners. */ export const eventify = function (target, getter, setter, enumerable) { target = target || this let _events = {} if (!getter &amp;&amp; !setter) { getter = function () { return _events } setter = function (value) { _events = value } } Object.defineProperties(target, { on: { enumerable: !!enumerable, value (type, func, ctx) { if (!getter.call(this)) { setter.call(this, {}) } const events = getter.call(this) events[type] = events[type] || [] events[type].push({ f: func, c: ctx }) } }, off: { enumerable: !!enumerable, value (type, func) { const events = getter.call(this) const listeners = events[type] if (!listeners) { setter.call(this, {}) } else if (func) { for (let i = 0; i &lt; listeners.length; i++) { if (listeners[i].f === func) { listeners.splice(i, 1) break } } } else { listeners.splice(0, listeners.length) } } }, emit: { enumerable: !!enumerable, value (...args) { const events = getter.call(this) || {} const type = args.shift() let listeners = events[type] || [] let i for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } listeners = events.all || [] args.unshift(type) for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } } } }) } export const classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function') } } export const possibleConstructorReturn = function (self, call) { if (!self) { throw new ReferenceError('this hasn\\'t been initialised - super() hasn\\'t been called') } return call &amp;&amp; (typeof call === 'object' || typeof call === 'function') ? call : self } export const addHiddenPropsToTarget = function (target, props) { forOwn(props, function (value, key) { props[key] = { writable: true, value } }) Object.defineProperties(target, props) } export const extend = function (props, classProps) { const SuperClass = this let SubClass props || (props = {}) classProps || (classProps = {}) if (props.hasOwnProperty('constructor')) { SubClass = props.constructor delete props.constructor } else { SubClass = function (...args) { classCallCheck(this, SubClass) const _this = possibleConstructorReturn(this, (SubClass.__super__ || Object.getPrototypeOf(SubClass)).apply(this, args)) return _this } } SubClass.prototype = Object.create(SuperClass &amp;&amp; SuperClass.prototype, { constructor: { value: SubClass, enumerable: false, writable: true, configurable: true } }) if (Object.setPrototypeOf) { Object.setPrototypeOf(SubClass, SuperClass) } else if (classProps.strictEs6Class) { SubClass.__proto__ = SuperClass // eslint-disable-line } else { forOwn(SuperClass, function (value, key) { SubClass[key] = value }) } Object.defineProperty(SubClass, '__super__', { configurable: true, value: SuperClass }) addHiddenPropsToTarget(SubClass.prototype, props) fillIn(SubClass, classProps) return SubClass } export const getSuper = function (instance) { const Ctor = instance.constructor return (Ctor.__super__ || Object.getPrototypeOf(Ctor) || Ctor.__proto__) // eslint-disable-line } × Search results Close Back to js-data.io "},"Query.js.html":{"id":"Query.js.html","title":"Source: Query.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Query.js import { addHiddenPropsToTarget, classCallCheck, extend, forOwn, get, intersection, isArray, isFunction, isNull, isNumber, isObject, isString } from './utils' /** * A class used by the {@link Collection} class to build queries to be executed * against the collection's data. An instance of `Query` is returned by * {@link Collection#query}. * * ```javascript * import {Query} from 'js-data' * ``` * * @class Query * @param {Collection} collection - The collection on which this query operates. */ export default function Query (collection) { classCallCheck(this, Query) /** * The collection on which this query operates. * * @name Query#collection * @type {Collection} */ this.collection = collection /** * The data result of this query. * * @name Query#data * @type {Array} */ this.data = null } /** * Create a Query subclass. * * ```javascript * var MyQuery = Query.extend({ * foo: function () { return 'bar' } * }) * var query = new MyQuery() * query.foo() // &quot;bar&quot; * ``` * * @name Query.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of Query. */ Query.extend = extend const reserved = { skip: '', offset: '', where: '', limit: '', orderBy: '', sort: '' } const escapeRegExp = /([.*+?^=!:${}()|[\\]\\/\\\\])/g const percentRegExp = /%/g const underscoreRegExp = /_/g function escape (pattern) { return pattern.replace(escapeRegExp, '\\\\$1') } /** * TODO * * @name Query.ops * @type {Object} */ Query.ops = { '==': function (value, predicate) { return value == predicate // eslint-disable-line }, '===': function (value, predicate) { return value === predicate }, '!=': function (value, predicate) { return value != predicate // eslint-disable-line }, '!==': function (value, predicate) { return value !== predicate }, '&gt;': function (value, predicate) { return value &gt; predicate }, '&gt;=': function (value, predicate) { return value &gt;= predicate }, '&lt;': function (value, predicate) { return value &lt; predicate }, '&lt;=': function (value, predicate) { return value &lt;= predicate }, 'isectEmpty': function (value, predicate) { return !intersection((value || []), (predicate || [])).length }, 'isectNotEmpty': function (value, predicate) { return intersection((value || []), (predicate || [])).length }, 'in': function (value, predicate) { return predicate.indexOf(value) !== -1 }, 'notIn': function (value, predicate) { return predicate.indexOf(value) === -1 }, 'contains': function (value, predicate) { return (value || []).indexOf(predicate) !== -1 }, 'notContains': function (value, predicate) { return (value || []).indexOf(predicate) === -1 } } addHiddenPropsToTarget(Query.prototype, { compare (orderBy, index, a, b) { const def = orderBy[index] let cA = get(a, def[0]) let cB = get(b, def[0]) if (cA &amp;&amp; isString(cA)) { cA = cA.toUpperCase() } if (cB &amp;&amp; isString(cB)) { cB = cB.toUpperCase() } a || (a = null) b || (b = null) if (def[1] === 'DESC') { if (cB &lt; cA) { return -1 } else if (cB &gt; cA) { return 1 } else { if (index &lt; orderBy.length - 1) { return this.compare(orderBy, index + 1, a, b) } else { return 0 } } } else { if (cA &lt; cB) { return -1 } else if (cA &gt; cB) { return 1 } else { if (index &lt; orderBy.length - 1) { return this.compare(orderBy, index + 1, a, b) } else { return 0 } } } }, evaluate (value, op, predicate) { if (Query.ops[op]) { return Query.ops[op](value, predicate) } if (op.indexOf('like') === 0) { return !isNull(this.like(predicate, op.substr(4)).exec(value)) } else if (op.indexOf('notLike') === 0) { return isNull(this.like(predicate, op.substr(7)).exec(value)) } }, like (pattern, flags) { return new RegExp(`^${(escape(pattern).replace(percentRegExp, '.*').replace(underscoreRegExp, '.'))}$`, flags) }, /** * Return the current data result of this query. * @name Query#getData * @method * @return {Array} The data in this query. */ getData () { if (!this.data) { this.data = this.collection.index.getAll() } return this.data }, /** * Find all entities between two boundaries. * * Get the users ages 18 to 30 * ```js * const users = query.between(18, 30, { index: 'age' }).run() * ``` * Same as above * ```js * const users = query.between([18], [30], { index: 'age' }).run() * ``` * * @name Query#between * @method * @param {Array} leftKeys - Keys defining the left boundary. * @param {Array} rightKeys - Keys defining the right boundary. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] - Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] - Whether to include entities * on the left boundary. * @param {boolean} [opts.rightInclusive=false] - Whether to include entities * on the left boundary. * @param {boolean} [opts.limit] - Limit the result to a certain number. * @param {boolean} [opts.offset] - The number of resulting entities to skip. * @return {Query} A reference to itself for chaining. */ between (leftKeys, rightKeys, opts) { opts || (opts = {}) const collection = this.collection const index = opts.index ? collection.indexes[opts.index] : collection.index if (this.data) { throw new Error('Cannot access index after first operation!') } this.data = index.between(leftKeys, rightKeys, opts) return this }, /** * Find the entity or entities that match the provided key. * * #### Example * * Get the entity whose primary key is 25 * ```js * const entities = query.get(25).run() * ``` * Same as above * ```js * const entities = query.get([25]).run() * ``` * Get all users who are active and have the &quot;admin&quot; role * ```js * const activeAdmins = query.get(['active', 'admin'], { * index: 'activityAndRoles' * }).run() * ``` * Get all entities that match a certain weather condition * ```js * const niceDays = query.get(['sunny', 'humid', 'calm'], { * index: 'weatherConditions' * }).run() * ``` * * @name Query#get * @method * @param {Array} keyList - Key(s) defining the entity to retrieve. If * `keyList` is not an array (i.e. for a single-value key), it will be * wrapped in an array. * @param {Object} [opts] - Configuration options. * @param {string} [opts.string] - Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @return {Query} A reference to itself for chaining. */ get (keyList = [], opts) { opts || (opts = {}) if (this.data) { throw new Error('Cannot access index after first operation!') } if (keyList &amp;&amp; !isArray(keyList)) { keyList = [keyList] } if (!keyList.length) { this.getData() return this } const collection = this.collection const index = opts.index ? collection.indexes[opts.index] : collection.index this.data = index.get(keyList) return this }, /** * Find the entity or entities that match the provided keyLists. * * #### Example * * Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; * ```js * const posts = query.getAll('draft', 'inReview', { index: 'status' }).run() * ``` * Same as above * ```js * const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() * ``` * * @name Query#getAll * @method * @param {...Array} [keyList] - Provide one or more keyLists, and all * entities matching each keyList will be retrieved. If no keyLists are * provided, all entities will be returned. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] - Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @return {Query} A reference to itself for chaining. */ getAll (...args) { let opts = {} if (this.data) { throw new Error('Cannot access index after first operation!') } if (!args.length || args.length === 1 &amp;&amp; isObject(args[0])) { this.getData() return this } else if (args.length &amp;&amp; isObject(args[args.length - 1])) { opts = args[args.length - 1] args.pop() } const collection = this.collection const index = opts.index ? collection.indexes[opts.index] : collection.index this.data = [] args.forEach(keyList =&gt; { this.data = this.data.concat(index.get(keyList)) }) return this }, /** * Find the entity or entities that match the provided query or pass the * provided filter function. * * #### Example * * Get the draft posts created less than three months * ```js * const posts = query.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }).run() * ``` * Use a custom filter function * ```js * const posts = query.filter(function (post) { * return post.isReady() * }).run() * ``` * * @name Query#filter * @method * @param {(Object|Function)} [queryOrFn={}] - Selection query or filter * function. * @param {Function} [thisArg] - Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @return {Query} A reference to itself for chaining. */ filter (query, thisArg) { const self = this query || (query = {}) self.getData() if (isObject(query)) { let where = {} // Filter if (isObject(query.where)) { where = query.where } forOwn(query, function (value, key) { if (!(key in reserved) &amp;&amp; !(key in where)) { where[key] = { '==': value } } }) const fields = [] const ops = [] const predicates = [] forOwn(where, function (clause, field) { if (!isObject(clause)) { clause = { '==': clause } } forOwn(clause, function (expr, op) { fields.push(field) ops.push(op) predicates.push(expr) }) }) if (fields.length) { let i let len = fields.length self.data = self.data.filter(function (item) { let first = true let keep = true for (i = 0; i &lt; len; i++) { let op = ops[i] const isOr = op.charAt(0) === '|' op = isOr ? op.substr(1) : op const expr = self.evaluate(get(item, fields[i]), op, predicates[i]) if (expr !== undefined) { keep = first ? expr : (isOr ? keep || expr : keep &amp;&amp; expr) } first = false } return keep }) } // Sort let orderBy = query.orderBy || query.sort if (isString(orderBy)) { orderBy = [ [orderBy, 'ASC'] ] } if (!isArray(orderBy)) { orderBy = null } // Apply 'orderBy' if (orderBy) { let index = 0 orderBy.forEach(function (def, i) { if (isString(def)) { orderBy[i] = [def, 'ASC'] } }) self.data.sort(function (a, b) { return self.compare(orderBy, index, a, b) }) } // Skip if (isNumber(query.skip)) { self.skip(query.skip) } else if (isNumber(query.offset)) { self.skip(query.offset) } // Limit if (isNumber(query.limit)) { self.limit(query.limit) } } else if (isFunction(query)) { self.data = self.data.filter(query, thisArg) } return self }, /** * Skip a number of results. * * #### Example * * Get all but the first 10 draft posts * ```js * const posts = query.get('draft', { index: 'status' }).skip(10).run() * ``` * * @name Query#skip * @method * @param {number} num - The number of entities to skip. * @return {Query} A reference to itself for chaining. */ skip (num) { if (!isNumber(num)) { throw new TypeError(`skip: Expected number but found ${typeof num}!`) } const data = this.getData() if (num &lt; data.length) { this.data = data.slice(num) } else { this.data = [] } return this }, /** * Limit the result. * * #### Example * * Get only the first 10 draft posts * ```js * const posts = query.get('draft', { index: 'status' }).limit(10).run() * ``` * * @name Query#limit * @method * @param {number} num - The maximum number of entities to keep in the result. * @return {Query} A reference to itself for chaining. */ limit (num) { if (!isNumber(num)) { throw new TypeError(`limit: Expected number but found ${typeof num}!`) } const data = this.getData() this.data = data.slice(0, Math.min(data.length, num)) return this }, /** * Iterate over all entities. * * @name Query#forEach * @method * @param {Function} forEachFn - Iteration function. * @param {*} [thisArg] - Context to which to bind `forEachFn`. * @return {Query} A reference to itself for chaining. */ forEach (forEachFn, thisArg) { this.getData().forEach(forEachFn, thisArg) return this }, /** * Apply a mapping function to the result data. * * @name Query#map * @method * @param {Function} mapFn - Mapping function. * @param {*} [thisArg] - Context to which to bind `mapFn`. * @return {Query} A reference to itself for chaining. */ map (mapFn, thisArg) { this.data = this.getData().map(mapFn, thisArg) return this }, /** * Return the result of calling the specified function on each item in this * collection's main index. * @name Query#mapCall * @method * @param {string} funcName - Name of function to call * @parama {...*} [args] - Remaining arguments to be passed to the function. * @return {Query} A reference to itself for chaining. */ mapCall (funcName, ...args) { this.data = this.getData().map(function (item) { return item[funcName](...args) }) return this }, /** * Complete the execution of the query and return the resulting data. * * @name Query#run * @method * @return {Array} The result of executing this query. */ run () { const data = this.data this.data = null return data } }) × Search results Close Back to js-data.io "},"Record.js.html":{"id":"Record.js.html","title":"Source: Record.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Record.js import { _, addHiddenPropsToTarget, classCallCheck, copy, eventify, extend, fillIn, forOwn, get, isFunction, isObject, isSorN, isString, resolve, set } from './utils' /** * js-data's Record class. * * ```javascript * import {Record} from 'js-data' * ``` * * @class Record * @param {Object} [props] The initial properties of the new Record instance. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation on the * initial properties. */ export default function Record (props, opts) { const self = this classCallCheck(self, Record) props || (props = {}) opts || (opts = {}) const _props = {} Object.defineProperties(self, { _get: { value (key) { return get(_props, key) } }, _set: { value (key, value) { return set(_props, key, value) } } }) self._set('creating', true) if (opts.noValidate) { self._set('noValidate', true) } fillIn(self, props) self._set('creating') // unset self._set('changes', {}) self._set('noValidate') // unset self._set('previous', copy(props)) } /** * Create a Record subclass. * * ```javascript * var MyRecord = Record.extend({ * foo: function () { return 'bar' } * }) * var record = new MyRecord() * record.foo() // &quot;bar&quot; * ``` * * @name Record.extend * @method * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @return {Function} Subclass of Record. */ Record.extend = extend addHiddenPropsToTarget(Record.prototype, { /** * TODO * * @name Record#_mapper * @method * @ignore */ _mapper () { if (!this.constructor.Mapper) { throw new Error('This RecordClass has no Mapper!') } return this.constructor.Mapper }, /** * Return the value at the given path for this instance. * * @name Record#get * @method * @param {string} key - Path of value to retrieve. * @return {*} Value at path. */ get: function (key) { return get(this, key) }, /** * Set the value for a given key, or the values for the given keys if &quot;key&quot; is * an object. * * @name Record#set * @method * @param {(string|Object)} key - Key to set or hash of key-value pairs to set. * @param {*} [value] - Value to set for the given key. * @param {Object} [opts] - Optional configuration. * @param {boolean} [opts.silent=false] - Whether to trigger change events. */ set: function (key, value, opts) { const self = this if (isObject(key)) { opts = value } opts || (opts = {}) if (opts.silent) { self._set('silent', true) } set(self, key, value) if (!self._get('eventId')) { self._set('silent') // unset } }, /** * Unset the value for a given key. * * @name Record#unset * @method * @param {string} key - Key to unset. * @param {Object} [opts] - Optional configuration. * @param {boolean} [opts.silent=false] - Whether to trigger change events. */ unset (key, opts) { this.set(key, undefined, opts) }, /** * TODO * * @name Record#hashCode * @method */ hashCode () { const self = this return get(self, self._mapper().idAttribute) }, /** * TODO * * @name Record#changes * @method * @param {string} [key] TODO */ changes (key) { const self = this if (key) { return self._get(`changes.${key}`) } return self._get('changes') }, /** * TODO * * @name Record#hasChanges * @method */ hasChanges () { return !!(this._get('changed') || []).length }, /** * TODO * * @name Record#commit * @method */ commit () { const self = this self._set('changed') // unset self._set('changes', {}) self._set('previous', copy(self)) return self }, /** * TODO * * @name Record#previous * @method * @param {string} [key] TODO */ previous (key) { const self = this if (key) { return self._get(`previous.${key}`) } return self._get('previous') }, /** * TODO * * @name Record#revert * @method * @param {Object} [opts] Configuration options. */ revert (opts) { const self = this const previous = self._get('previous') || {} opts || (opts = {}) opts.preserve || (opts.preserve = []) forOwn(self, (value, key) =&gt; { if (key !== self._mapper().idAttribute &amp;&amp; !previous.hasOwnProperty(key) &amp;&amp; self.hasOwnProperty(key) &amp;&amp; opts.preserve.indexOf(key) === -1) { delete self[key] } }) forOwn(previous, (value, key) =&gt; { if (opts.preserve.indexOf(key) === -1) { self[key] = value } }) self.commit() return self }, /** * TODO * * @name Record#schema * @method * @param {string} [key] TODO */ schema (key) { let _schema = this._mapper().schema return key ? _schema[key] : _schema }, // validate (obj, value) { // let errors = [] // let _schema = this.schema() // if (!obj) { // obj = this // } else if (utils.isString(obj)) { // const prop = _schema[obj] // if (prop) { // errors = validate.validate(prop, value) || [] // } // } else { // utils.forOwn(_schema, function (prop, key) { // errors = errors.concat(validate.validate(prop, utils.get(obj, key)) || []) // }) // } // return errors.length ? errors : undefined // }, /** * TODO * * @name Record#create * @method * @param {Object} [opts] Configuration options. See {@link Mapper#create}. */ create (opts) { return this._mapper().create(this, opts) }, /** * TODO * * @name Record#beforeSave * @method * @param {Object} opts TODO */ beforeSave () {}, /** * TODO * * @name Record#save * @method * @param {Object} [opts] Configuration options. See {@link Mapper#create}. */ save (opts) { let op, adapter const self = this const Mapper = self._mapper() // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Model's configuration _(self, opts) adapter = opts.adapter = self.getAdapterName(opts) // beforeSave lifecycle hook op = opts.op = 'beforeSave' return resolve(self[op](opts)).then(function () { // Now delegate to the adapter op = opts.op = 'save' Mapper.dbg(op, self, opts) return self.getAdapter(adapter)[op](Mapper, self, opts) }).then(function (data) { // afterSave lifecycle hook op = opts.op = 'afterSave' return resolve(self[op](data, opts)).then(function (_data) { // Allow for re-assignment from lifecycle hook data = _data || data if (opts.raw) { self.set(data.data) data.data = self } else { self.set(data) } return Mapper.end(data, opts) }) }) }, /** * TODO * * @name Record#afterSave * @method * @param {Object} opts TODO */ afterSave () {}, /** * TODO * * @name Record#beforeLoadRelations * @method * @param {string[]} relations TODO * @param {Object} opts TODO */ beforeLoadRelations () {}, /** * TODO * * @name Record#loadRelations * @method * @param {string[]} [relations] TODO * @param {Object} [opts] TODO */ loadRelations (relations, opts) { let op const self = this const Mapper = self._mapper() const relationList = Mapper.relationList || [] // Default values for arguments relations || (relations = []) opts || (opts = {}) // Fill in &quot;opts&quot; with the Model's configuration _(Mapper, opts) opts.adapter = Mapper.getAdapterName(opts) // beforeLoadRelations lifecycle hook op = opts.op = 'beforeLoadRelations' return resolve(self[op](relations, opts)).then(function () { if (isString(relations)) { relations = [relations] } // Now delegate to the adapter op = opts.op = 'loadRelations' Mapper.dbg(op, self, relations, opts) return Promise.all(relationList.map(function (def) { if (isFunction(def.load)) { return def.load(Mapper, def, self, opts) } let task if (def.type === 'hasMany' &amp;&amp; def.foreignKey) { // hasMany task = def.getRelation().findAll({ [def.foreignKey]: get(self, Mapper.idAttribute) }, opts) } else if (def.foreignKey) { // belongsTo or hasOne const key = get(self, def.foreignKey) if (isSorN(key)) { task = def.getRelation().find(key, opts) } } else if (def.localKeys) { // hasMany task = def.getRelation().findAll({ [def.getRelation().idAttribute]: { 'in': get(self, def.localKeys) } }, opts) } else if (def.foreignKeys) { // hasMany task = def.getRelation().findAll({ [def.getRelation().idAttribute]: { 'contains': get(self, Mapper.idAttribute) } }, opts) } if (task) { task = task.then(function (data) { if (opts.raw) { data = data.data } set(self, def.localField, def.type === 'hasOne' ? (data.length ? data[0] : undefined) : data) }) } return task })) }).then(function () { // afterLoadRelations lifecycle hook op = opts.op = 'afterLoadRelations' return resolve(self[op](relations, opts)).then(function () { return self }) }) }, /** * TODO * * @name Record#afterLoadRelations * @method * @param {string[]} relations TODO * @param {Object} opts TODO */ afterLoadRelations () {}, /** * TODO * * @name Record#destroy * @method * @param {Object} [opts] Configuration options. @see {@link Model.destroy}. */ destroy (opts) { // TODO: move actual destroy logic here const Mapper = this._mapper() return Mapper.destroy(get(this, Mapper.idAttribute), opts) }, // TODO: move logic for single-item async operations onto the instance. toJSON (opts) { return this._mapper().toJSON(this, opts) } }) /** * Register a new event listener on this Record. * * @name Record#on * @method */ /** * Remove an event listener from this Record. * * @name Record#off * @method */ /** * Trigger an event on this Record. * * @name Record#emit * @method * @param {string} event Name of event to emit. */ /** * Allow records to emit events. * * An record's registered listeners are stored in the record's private data. */ eventify( Record.prototype, function () { return this._get('events') }, function (value) { this._set('events', value) } ) × Search results Close Back to js-data.io "},"Schema.js.html":{"id":"Schema.js.html","title":"Source: Schema.js","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Schema.js import { copy, extend, fillIn, forOwn, get, isArray, isBoolean, isFunction, isInteger, isNumber, isNull, isObject, isString, isUndefined } from './utils' /** * js-data's Schema class. * * ```javascript * import {Schema} from 'js-data' * ``` * * @class Schema * @param {Object} definition Schema definition according to json-schema.org */ export default function Schema (definition) { // const self = this definition || (definition = {}) // TODO: schema validation fillIn(this, definition) // TODO: rework this to make sure all possible keywords are converted // if (definition.properties) { // forOwn(definition.properties, function (_definition, prop) { // definition.properties[prop] = new Schema(_definition) // }) // } } /** * @name Schema.extend * @method */ Schema.extend = extend /** * TODO * * @name Schema.types * @type {Object} */ const types = { array: isArray, boolean: isBoolean, integer: isInteger, 'null': isNull, number: isNumber, object: isObject, string: isString } /** * TODO * * @name Schema.typeGroupValidators * @type {Object} */ const typeGroupValidators = {} /** * TODO * * @name Schema.validationKeywords * @type {Object} */ const validationKeywords = {} /** * @ignore */ const segmentToString = function (segment, prev) { let str = '' if (segment) { if (isNumber(segment)) { str += `[${segment}]` } else if (prev) { str += `.${segment}` } else { str += `${segment}` } } return str } /** * @ignore */ const makePath = function (opts) { opts || (opts = {}) let path = '' const segments = opts.path || [] segments.forEach(function (segment) { path += segmentToString(segment, path) }) path += segmentToString(opts.prop, path) return path } /** * @ignore */ const makeError = function (actual, expected, opts) { return { expected, actual: '' + actual, path: makePath(opts) } } /** * @ignore */ const addError = function (actual, expected, opts, errors) { errors.push(makeError(actual, expected, opts)) } /** * @ignore */ const maxLengthCommon = function (keyword, value, schema, opts) { const max = schema[keyword] if (value.length &gt; max) { return makeError(value.length, `length no more than ${max}`, opts) } } /** * @ignore */ const minLengthCommon = function (keyword, value, schema, opts) { const min = schema[keyword] if (value.length &lt; min) { return makeError(value.length, `length no less than ${min}`, opts) } } /** * @ignore */ const validateKeyword = function (op, value, schema, opts) { return !isUndefined(schema[op]) &amp;&amp; validationKeywords[op](value, schema, opts) } /** * @ignore */ const runOps = function (ops, value, schema, opts) { let errors = [] ops.forEach(function (op) { errors = errors.concat(validateKeyword(op, value, schema, opts) || []) }) return errors.length ? errors : undefined } const ANY_OPS = ['enum', 'type', 'allOf', 'anyOf', 'oneOf', 'not'] const ARRAY_OPS = ['items', 'maxItems', 'minItems', 'uniqueItems'] const NUMERIC_OPS = ['multipleOf', 'maximum', 'minimum'] const OBJECT_OPS = ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] const STRING_OPS = ['maxLength', 'minLength', 'pattern'] /** * http://json-schema.org/latest/json-schema-validation.html#anchor75 * @ignore */ const validateAny = function (value, schema, opts) { return runOps(ANY_OPS, value, schema, opts) } /** * TODO * * @name Schema.validate * @method * @param {*} value TODO * @param {Object} [schema] TODO * @param {Object} [opts] Configuration options. */ export const validate = function (value, schema, opts) { let errors = [] opts || (opts = {}) let shouldPop let prevProp = opts.prop if (isUndefined(schema)) { return } if (!isObject(schema)) { throw new Error(`Invalid schema at path: &quot;${opts.path}&quot;`) } if (isUndefined(opts.path)) { opts.path = [] } // Track our location as we recurse if (!isUndefined(opts.prop)) { shouldPop = true opts.path.push(opts.prop) opts.prop = undefined } // Validate against parent schema if (schema['extends']) { // opts.path = path // opts.prop = prop if (isFunction(schema['extends'].validate)) { errors = errors.concat(schema['extends'].validate(value, opts) || []) } else { errors = errors.concat(validate(value, schema['extends'], opts) || []) } } if (isUndefined(value)) { // Check if property is required if (schema.required === true) { addError(value, 'a value', opts, errors) } if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } errors = errors.concat(validateAny(value, schema, opts) || []) if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } Schema.types = types Schema.typeGroupValidators = typeGroupValidators Schema.validationKeywords = validationKeywords Schema.validate = validate /** * Validate the provided value against this schema. * * @name Schema#validate * @method * @param {*} value Value to validate. * @param {Object} [opts] Configuration options. * @return {(array|undefined)} Array of errors or `undefined` if valid. */ Schema.prototype.validate = function (value, opts) { return Schema.validate(value, this, opts) } fillIn(validationKeywords, { /** * http://json-schema.org/latest/json-schema-validation.html#anchor82 * * @name Schema.validationKeywords.allOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ allOf (value, schema, opts) { let allErrors = [] schema.allOf.forEach(function (_schema) { allErrors = allErrors.concat(validate(value, _schema, opts) || []) }) return allErrors.length ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor85 * * @name Schema.validationKeywords.anyOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ anyOf (value, schema, opts) { let validated = false let allErrors = [] schema.anyOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor70 * * @name Schema.validationKeywords.dependencies * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ dependencies (value, schema, opts) { // TODO }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor76 * * @name Schema.validationKeywords.enum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ enum (value, schema, opts) { const possibleValues = schema['enum'] if (possibleValues.indexOf(value) === -1) { return makeError(value, `one of (${possibleValues.join(', ')})`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor37 * * @name Schema.validationKeywords.items * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ items (value, schema, opts) { opts || (opts = {}) // TODO: additionalItems let items = schema.items let errors = [] const checkingTuple = isArray(items) const length = value.length for (var prop = 0; prop &lt; length; prop++) { if (checkingTuple) { // Validating a tuple, instead of just checking each item against the // same schema items = schema.items[prop] } opts.prop = prop errors = errors.concat(validate(value[prop], items, opts) || []) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor17 * * @name Schema.validationKeywords.maximum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maximum (value, schema, opts) { // Must be a number const maximum = schema.maximum // Must be a boolean // Depends on maximum // default: false const exclusiveMaximum = schema.exclusiveMaximum if (typeof value === typeof maximum &amp;&amp; (exclusiveMaximum ? maximum &lt; value : maximum &lt;= value)) { // TODO: Account for value of exclusiveMaximum in messaging return makeError(value, `no more than ${maximum}`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.maxItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxItems (value, schema, opts) { return maxLengthCommon('maxItems', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor26 * * @name Schema.validationKeywords.maxLength * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxLength (value, schema, opts) { return maxLengthCommon('maxLength', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor54 * * @name Schema.validationKeywords.maxProperties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxProperties (value, schema, opts) { const maxProperties = schema.maxProperties const length = Object.keys(value).length if (length &gt; maxProperties) { return makeError(length, `no more than ${maxProperties} properties`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor21 * * @name Schema.validationKeywords.minimum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minimum (value, schema, opts) { // Must be a number const minimum = schema.minimum // Must be a boolean // Depends on minimum // default: false const exclusiveMinimum = schema.exclusiveMinimum if (typeof value === typeof minimum &amp;&amp; (exclusiveMinimum ? minimum &gt; value : minimum &gt;= value)) { // TODO: Account for value of exclusiveMinimum in messaging return makeError(value, `no less than ${minimum}`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.minItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minItems (value, schema, opts) { return minLengthCommon('minItems', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor29 * * @name Schema.validationKeywords.minLength * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minLength (value, schema, opts) { return minLengthCommon('minLength', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor57 * * @name Schema.validationKeywords.minProperties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minProperties (value, schema, opts) { const minProperties = schema.minProperties const length = Object.keys(value).length if (length &lt; minProperties) { return makeError(length, `no more than ${minProperties} properties`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor14 * * @name Schema.validationKeywords.multipleOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ multipleOf (value, schema, opts) { // TODO }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor91 * * @name Schema.validationKeywords.not * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ not (value, schema, opts) { if (!validate(value, schema.not, opts)) { // TODO: better messaging return makeError('succeeded', 'should have failed', opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor88 * * @name Schema.validationKeywords.oneOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ oneOf (value, schema, opts) { let validated = false let allErrors = [] schema.oneOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else if (validated) { allErrors = [makeError('valid against more than one', 'valid against only one', opts)] validated = false return false } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor33 * * @name Schema.validationKeywords.pattern * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ pattern (value, schema, opts) { const pattern = schema.pattern if (isString(value) &amp;&amp; !value.match(pattern)) { return makeError(value, pattern, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor64 * * @name Schema.validationKeywords.properties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ properties (value, schema, opts) { opts || (opts = {}) // Can be a boolean or an object // Technically the default is an &quot;empty schema&quot;, but here &quot;true&quot; is // functionally the same const additionalProperties = isUndefined(schema.additionalProperties) ? true : schema.additionalProperties // &quot;s&quot;: The property set of the instance to validate. const toValidate = {} // &quot;p&quot;: The property set from &quot;properties&quot;. // Default is an object const properties = schema.properties || {} // &quot;pp&quot;: The property set from &quot;patternProperties&quot;. // Default is an object const patternProperties = schema.patternProperties || {} let errors = [] // Collect set &quot;s&quot; forOwn(value, function (_value, prop) { toValidate[prop] = undefined }) // Remove from &quot;s&quot; all elements of &quot;p&quot;, if any. forOwn(properties || {}, function (_schema, prop) { if (isUndefined(value[prop]) &amp;&amp; !isUndefined(_schema['default'])) { value[prop] = copy(_schema['default']) } opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] }) // For each regex in &quot;pp&quot;, remove all elements of &quot;s&quot; which this regex // matches. forOwn(patternProperties, function (_schema, pattern) { forOwn(toValidate, function (undef, prop) { if (prop.match(pattern)) { opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] } }) }) const keys = Object.keys(toValidate) // If &quot;s&quot; is not empty, validation fails if (additionalProperties === false) { if (keys.length) { addError(`extra fields: ${keys.join(', ')}`, 'no extra fields', opts, errors) } } else if (isObject(additionalProperties)) { // Otherwise, validate according to provided schema keys.forEach(function (prop) { opts.prop = prop errors = errors.concat(validate(value[prop], additionalProperties, opts) || []) }) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor61 * * @name Schema.validationKeywords.required * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ required (value, schema, opts) { const required = schema.required let errors = [] if (!opts.existingOnly) { required.forEach(function (prop) { if (isUndefined(get(value, prop))) { const prevProp = opts.prop opts.prop = prop addError(undefined, 'a value', opts, errors) opts.prop = prevProp } }) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor79 * * @name Schema.validationKeywords.type * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ type (value, schema, opts) { let type = schema.type let validType // Can be one of several types if (isString(type)) { type = [type] } // Try to match the value against an expected type type.forEach(function (_type) { // TODO: throw an error if type is not defined if (types[_type](value, schema, opts)) { // Matched a type validType = _type return false } }) // Value did not match any expected type if (!validType) { return makeError(value ? typeof value : '' + value, `one of (${type.join(', ')})`, opts) } // Run keyword validators for matched type // http://json-schema.org/latest/json-schema-validation.html#anchor12 const validator = typeGroupValidators[validType] if (validator) { return validator(value, schema, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor49 * * @name Schema.validationKeywords.uniqueItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ uniqueItems (value, schema, opts) { if (value &amp;&amp; value.length &amp;&amp; schema.uniqueItems) { const length = value.length let item, i, j // Check n - 1 items for (i = length - 1; i &gt; 0; i--) { item = value[i] // Only compare against unchecked items for (j = i - 1; j &gt;= 0; j--) { // Found a duplicate if (item === value[j]) { return makeError(item, 'no duplicates', opts) } } } } } }) fillIn(typeGroupValidators, { /** * TODO * * @name Schema.typeGroupValidators.array * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ array: function (value, schema, opts) { return runOps(ARRAY_OPS, value, schema, opts) }, /** * TODO * * @name Schema.typeGroupValidators.integer * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ integer: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * TODO * * @name Schema.typeGroupValidators.number * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ number: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor13. * * @name Schema.typeGroupValidators.numeric * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ numeric: function (value, schema, opts) { return runOps(NUMERIC_OPS, value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor53. * * @name Schema.typeGroupValidators.object * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ object: function (value, schema, opts) { return runOps(OBJECT_OPS, value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor25. * * @name Schema.typeGroupValidators.string * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ string: function (value, schema, opts) { return runOps(STRING_OPS, value, schema, opts) } }) × Search results Close Back to js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Modules Classes Collection Container DataStore LinkedCollection Mapper Query Record Schema × Search results Close Back to js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Classes Classes Collection Container DataStore LinkedCollection Mapper Query Record Schema × Search results Close Back to js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema js-data 3.0.0-alpha.11 JSData JSData is a framework-agnostic, datastore-agnostic ORM/ODM for Node.js and the Browser. Adapters allow JSData to connect to various data sources such as Firebase, MySql, RethinkDB, MongoDB, localStorage, Redis, a REST API, etc. With JSData you can re-use your Models between environments, keep your data layer intact when transitioning between app frameworks, and work with a unified data API on the server and the client. JSData employs conventions for rapid development, but allows for endless customization in order to meet your particular needs. Think of it as the &quot;Twitter Bootstrap&quot; of JavaScript data layers. To get started, check out js-data.io! Table of contents Quick start Background Dependencies Documentation API Reference Support Community Contributing License Quick Startjs-data + http adapter in the Browsernpm install --save js-data js-data-http or bower install --save js-data js-data-http. (Substitute js-data-http for any one of the other client-side adapters.) js-data + http adapter in Node.jsnpm install --save js-data axios js-data-http-node (Substitute axios and js-data-http-node for any one of the other server-side adapters.) See installation instructions for making JSData part of your r.js/browserify/webpack build. import {DataStore} from 'js-data' import HttpAdapter from 'js-data-http' // Create an empty data store const store = new DataStore() // &quot;store&quot; will use an http adapter by default store.registerAdapter('http', new HttpAdapter(), { 'default': true }) // Define a new Mapper for a &quot;user&quot; resource store.defineMapper('user') // Get a reference to the store's &quot;user&quot; collection const Users = store.getCollection('user') async function showExample () { let user = await store.find('user', 1) console.log(user) // { id: 1, name: 'John' } // The user record is now stored in Users console.log(Users.get(user.id)) // { id: 1, name: 'John' } console.log(user === Users.get(user.id)) // true user.name = 'Johnny' // PUT /user/1 {name:&quot;Johnny&quot;} user = await user.save() // The user record has been updated console.log(Users.get(user.id)) // { id: 1, name: 'Johnny' } console.log(user === Users.get(user.id)) // true await user.destroy() // The user instance no longer stored in UserCollection console.log(Users.get(1)) // undefined }ES5: // Create an empty data store var store = new JSData.DataStore() // &quot;store&quot; will use an http adapter by default store.registerAdapter('http', new HttpAdapter(), { default: true }) // Define a new Mapper for a &quot;user&quot; resource store.defineMapper('user') // Get a reference to the store's &quot;user&quot; collection var Users = store.getCollection('user') store.find('user', 1) .then(function (user) { console.log(user) // { id: 1, name: 'John' } // The user record is now stored in Users console.log(Users.get(user.id)) // { id: 1, name: 'John' } console.log(user === Users.get(user.id)) // true user.name = 'Johnny' // PUT /user/1 {name:&quot;Johnny&quot;} return user.save() }) .then(function (user) { // The user record has been updated console.log(Users.get(user.id)) // { id: 1, name: 'Johnny' } console.log(user === Users.get(user.id)) // true return user.destroy() }) .then(function () { // The user instance no longer stored in UserCollection console.log(Users.get(1)) // undefined })BackgroundMost ORMs/ODMs only work with a single datastore. Even when written in JavaScript, most ORMs/ODMs only work in Node.js or the Browser. Wouldn't it be nice if you could use the same ORM/ODM on the client as you do on the backend? Wouldn't it be nice if you could switch databases without having to switch out your data layer? Enter JSData. Originally inspired by the desire to have something like Ember Data that worked in Angular.js and other frameworks, JSData was created. Turns out, JSData works in Node.js, so server-side adapters were written. JSData is the Model layer you've been craving. It consists of a convenient framework-agnostic, datastore-agnostic ORM for managing your data, which uses adapters to connect to various persistence layers. The most commonly used adapter is the http adapter, which is perfect for connecting your frontend to your backend. localStorage, localForage, Firebase and other adapters are already available. On the server you could hook up to the SQL adapter (Postgres/MySQL/MariaDB/SQLite3) or the MongoDB adapter. More adapters are coming, and you're free to implement your own. See Adapters. DependenciesJSData requires the presence of a Promise constructor in the global environment. In the browser, window.Promise must be available. In Node.js, global.Promise must be available. Here is a handy library for polyfilling: https://github.com/jakearchibald/es6-promise. JSData also requires full ES5 support from the runtime. Here is a handy library for polyfilling: https://github.com/afarkas/html5shiv Documentation Getting Started with js-data Resources/Models Working with the Data Store Adapters Model Lifecycle Custom Instance Behavior Computed Properties Relations Schemata &amp; Validation JSData on the server Angular + JSData FAQ CHANGELOG.md See an issue with the documentation? Have something to add? Click the &quot;Suggest Edits&quot; at the top right of each page and make your suggested changes! API Reference DS Configuration Options DSFirebaseAdapter DSHttpAdapter DSLevelUpAdapter DSLocalForageAdapter DSLocalStorageAdapter DSMongoDBAdapter DSNeDBAdapter DSRedisAdapter DSRethinkDBAdapter DSSqlAdapter js-data-schema SupportSupport questions are handled via Stack Overflow, Slack, and the Mailing List. Ask your questions there. Community StackOverflow Slack chat Announcements Mailing List Issue Tracker GitHub Contributing Guide ContributingWhen submitting bug reports or feature requests on GitHub, please include as much detail as possible. good - Your versions of Angular, JSData, etc, relevant console logs, stack traces, code examples that revealed the issue, etc. better - A plnkr, fiddle, or bin that demonstrates the issue best - A Pull Request that fixes the issue, including test coverage for the issue and the fix Pull Requests Contribute to the issue/discussion that is the reason you'll be developing in the first place Fork js-data git clone git@github.com:&lt;you&gt;/js-data.git cd js-data; npm install; Write your code, including relevant documentation and tests Run npm test (build and test) Your code will be linted and checked for formatting, the tests will be run The dist/ folder &amp; files will be generated, do NOT commit dist/*! They will be committed when a release is cut. Submit your PR and we'll review! Thanks! LicenseThe MIT License (MIT) Copyright (c) 2014-2016 Jason Dobry Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. × Search results Close Back to js-data.io "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Collection Collection new Collection(records, opts) import {Collection} from 'js-data'An ordered set of Record instances. Parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description idAttribute string &lt;optional&gt; See Collection#idAttribute. onConflict string &lt;optional&gt; &quot;merge&quot; See Collection#onConflict. mapper string &lt;optional&gt; See Collection#mapper. recordOpts Object &lt;optional&gt; null See Collection#recordOpts. Source: Collection.js, line 88 Example import {Collection, Record} from 'js-data' const user1 = new Record({ id: 1 }) const user2 = new Record({ id: 2 }) const UserCollection = new Collection([user1, user2]) UserCollection.get(1) === user1 // true Members idAttribute :string Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Type: string Default Value: &quot;id&quot; Source: Collection.js, line 21 index :Index The main index, which uses @{link Collection#recordId} as the key. Type: Index Source: Collection.js, line 143 indexes :Object.&lt;string, Index&gt; Object that holds the secondary indexes of this collection. Type: Object.&lt;string, Index&gt; Source: Collection.js, line 154 mapper :Mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#RecordClass. Type: Mapper Default Value: null Source: Collection.js, line 32 Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict :string What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Type: string Default Value: &quot;merge&quot; Source: Collection.js, line 52 recordOpts :Object Options to be passed into Mapper#createRecord when wrapping records in Mapper#RecordClass. Type: Object Default Value: null Source: Collection.js, line 77 Methods &lt;static&gt; extend(props, classProps) Create a Collection subclass. Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: Collection.js, line 170 Returns: Subclass of Collection. Type function Example var MyCollection = Collection.extend({ foo: function () { return 'bar' } }) var collection = new MyCollection() collection.foo() // &quot;bar&quot; add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description onConflict string &lt;optional&gt; What to do when a record is already in the collection. Possible values are merge or replace. Source: Collection.js, line 202 Returns: The added record or records. Type Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Parameters: Name Type Description id string | number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Source: Collection.js, line 306 afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Source: Collection.js, line 318 beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Source: Collection.js, line 331 beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Parameters: Name Type Description id string | number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Source: Collection.js, line 343 beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Source: Collection.js, line 353 between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive boolean &lt;optional&gt; false Whether to include records on the left boundary. limit boolean &lt;optional&gt; Limit the result to a certain number. offset boolean &lt;optional&gt; The number of resulting records to skip. Source: Collection.js, line 363 Returns: The result. Type Array Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Parameters: Name Type Argument Description name string The name of the new secondary index. fieldList Array.&lt;string&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Source: Collection.js, line 393 Returns: A reference to itself for chaining. Type Collection Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) emit(event, arg) TODO Parameters: Name Type Argument Description event string TODO. arg * &lt;optional&gt; &lt;repeatable&gt; TODO Source: Collection.js, line 773 filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Parameters: Name Type Argument Default Description queryOrFn Object | function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Source: Collection.js, line 424 Returns: The result. Type Array Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Parameters: Name Type Argument Description forEachFn function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Source: Collection.js, line 459 Returns: The result. Type Array Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Parameters: Name Type Description id string | number The primary key of the record to get. Source: Collection.js, line 477 Returns: The record with the given id. Type Object | Record getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Source: Collection.js, line 490 Returns: The result. Type Array Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Parameters: Name Type Description num number The maximum number of records to keep in the result. Source: Collection.js, line 515 Returns: The result. Type Array Example const posts = collection.limit(10) map(mapFn, thisArg) Apply a mapping function to all records. Parameters: Name Type Argument Description mapFn function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Source: Collection.js, line 532 Returns: The result of the mapping. Type Array Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Parameters: Name Type Description funcName string Name of function to call Source: Collection.js, line 554 Returns: The result. Type Array method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Source: Collection.js, line 294 off(event, handler) TODO Parameters: Name Type Argument Description event string &lt;optional&gt; TODO. handler function &lt;optional&gt; TODO Source: Collection.js, line 764 on(event, handler) TODO Parameters: Name Type Description event string TODO. handler function TODO Source: Collection.js, line 755 query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Source: Collection.js, line 591 Returns: New query object. Type Query Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Source: Collection.js, line 572 Returns: Primary key or name of field that holds primary key. Type string | number reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Parameters: Name Type Description cb function Reduction callback. initialValue * Initial value of the reduction. Source: Collection.js, line 610 Returns: The result. Type * Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Parameters: Name Type Argument Description id string | number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Source: Collection.js, line 629 Returns: The removed record, if any. Type Object | Record removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip number &lt;optional&gt; Number to skip. limit number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Source: Collection.js, line 660 Returns: The removed records, if any. Type Array.&lt;Object&gt; | Array.&lt;Record&gt; skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Parameters: Name Type Description num number The number of records to skip. Source: Collection.js, line 687 Returns: The result. Type Array Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;string&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Source: Collection.js, line 704 Returns: The records. Type Array updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index string &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Source: Collection.js, line 719 updateIndexes(record, opts) TODO Parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Source: Collection.js, line 738 × Search results Close Back to js-data.io "},"Container.html":{"id":"Container.html","title":"Class: Container","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Container Container new Container(opts) import {Container} from 'js-data'The Container class is a place to store Mapper instances. Without a container, you need to manage mappers yourself, including resolving circular dependencies among relations. All mappers in a container share the same adapters, so you don't have to add each adapter to all of your mappers. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description MapperClass function &lt;optional&gt; Constructor function to use in Container#defineMapper to create a new mapper. mapperDefaults Object &lt;optional&gt; Defaults options to pass to Container#MapperClass when creating a new mapper. Source: Container.js, line 17 Returns: Type Container Examples Without Container import {Mapper} from 'js-data' import HttpAdapter from 'js-data-http' const adapter = new HttpAdapter() const userMapper = new Mapper({ name: 'user' }) userMapper.registerAdapter('http', adapter, { default: true }) const commentMapper = new Mapper({ name: 'comment' }) commentMapper.registerAdapter('http', adapter, { default: true }) // This might be more difficult if the mappers were defined in different // modules. userMapper.hasMany(commentMapper, { localField: 'comments', foreignKey: 'userId' }) commentMapper.belongsTo(userMapper, { localField: 'user', foreignKey: 'userId' }) With Container import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() // All mappers in container share adapters container.registerAdapter('http', new HttpAdapter(), { default: true }) // These could be defined in separate modules without a problem. container.defineMapper('user', { relations: { hasMany: { comment: { localField: 'comments', foreignKey: 'userId' } } } }) container.defineMapper('comment', { relations: { belongsTo: { user: { localField: 'user', foreignKey: 'userId' } } } }) Members MapperClass :function Constructor function to use in Container#defineMapper to create a new mapper. Type: function Source: Container.js, line 100 mapperDefaults :Object Defaults options to pass to Container#MapperClass when creating a new mapper. Type: Object Source: Container.js, line 92 Methods &lt;static&gt; extend(props, classProps) Create a Container subclass. Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: Container.js, line 117 Returns: Subclass of Container. Type function Example var MyContainer = Container.extend({ foo: function () { return 'bar' } }) var container = new MyContainer() container.foo() // &quot;bar&quot; defineMapper(name, opts) Create a new mapper and register it in this container. Parameters: Name Type Argument Description name string Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#MapperClass when creating the new Mapper. Source: Container.js, line 137 Returns: Type Mapper Example import {Container} from 'js-data' const container = new Container({ mapperDefaults: { foo: 'bar' } }) const userMapper = container.defineMapper('user') userMapper.foo // &quot;bar&quot; getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Parameters: Name Type Argument Description name string &lt;optional&gt; The name of the adapter to retrieve. Source: Container.js, line 233 Returns: The adapter. Type Adapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Parameters: Name Type Argument Description opts Object | string &lt;optional&gt; The name of an adapter or options, if any. Source: Container.js, line 216 Returns: The name of the adapter. Type string getAdapters() Return the registered adapters of this container. Source: Container.js, line 251 Returns: Type Adapter getMapper(name) Return the mapper registered under the specified name. Parameters: Name Type Description name string Mapper#name. Source: Container.js, line 262 Returns: Type Mapper Example import {Container} from 'js-data' const container = new Container() const userMapper = container.defineMapper('user') userMapper === container.getMapper('user') // true registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Parameters: Name Type Argument Description name string The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Source: Container.js, line 284 Example import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() container.registerAdapter('http', new HttpAdapter, { default: true }) × Search results Close Back to js-data.io "},"DataStore.html":{"id":"DataStore.html","title":"Class: DataStore","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: DataStore DataStore new DataStore(opts) The DataStore class is an extension of Container. Not only does DataStore manage mappers, but also collections. DataStore implements the asynchronous Mapper methods, such as Mapper#find and Mapper#create. If you use the asynchronous DataStore methods instead of calling them directly on the mappers, then the results of the method calls will be inserted into the store's collections. You can think of a DataStore as an Identity Map for the ORM (the Mappers). import {DataStore} from 'js-data' Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Container. Source: DataStore.js, line 15 Returns: Type DataStore Example import {DataStore} from 'js-data' import HttpAdapter from 'js-data-http' const store = new DataStore() const UserMapper = store.defineMapper('user') // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) UserMapper.find(1).then(function (user) { // retrieved a &quot;user&quot; record via the http adapter, but that's it // Call &quot;find&quot; on &quot;store&quot; for the &quot;user&quot; mapper (Stateful DataStore) return store.find('user', 1) }).then(function (user) { // not only was a &quot;user&quot; record retrieved, but it was added to the // store's &quot;user&quot; collection const cachedUser = store.getCollection('user').get(1) user === cachedUser // true }) Extends Container Members MapperClass :function Constructor function to use in Container#defineMapper to create a new mapper. Type: function Inherited From: Container#MapperClass Source: Container.js, line 100 mapperDefaults :Object Defaults options to pass to Container#MapperClass when creating a new mapper. Type: Object Inherited From: Container#mapperDefaults Source: Container.js, line 92 Methods &lt;static&gt; extend(props, classProps) Create a DataStore subclass. var MyDataStore = DataStore.extend({ foo: function () { return 'bar' } }) var store = new MyDataStore() store.foo() // &quot;bar&quot; Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: DataStore.js, line 326 Returns: Subclass of DataStore. Type function create(name, record, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. record Object Passed to Mapper#create. opts Object &lt;optional&gt; Passed to Mapper#create. See Mapper#create for more configuration options. Source: DataStore.js, line 88 Returns: Type Promise createMany(name, records, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. records Array Passed to Mapper#createMany. opts Object &lt;optional&gt; Passed to Mapper#createMany. See Mapper#createMany for more configuration options. Source: DataStore.js, line 108 Returns: Type Promise defineMapper(name, opts) Create a new mapper and register it in this container. Parameters: Name Type Argument Description name string Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#MapperClass when creating the new Mapper. Inherited From: Container#defineMapper Source: Container.js, line 137 Returns: Type Mapper Example import {Container} from 'js-data' const container = new Container({ mapperDefaults: { foo: 'bar' } }) const userMapper = container.defineMapper('user') userMapper.foo // &quot;bar&quot; destroy(name, id, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. id string | number Passed to Mapper#destroy. opts Object &lt;optional&gt; Passed to Mapper#destroy. See Mapper#destroy for more configuration options. Source: DataStore.js, line 157 Returns: Type Promise find(name, id, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. id string | number Passed to Mapper#find. opts Object &lt;optional&gt; Passed to Mapper#find. Source: DataStore.js, line 207 Returns: Type Promise findAll(name, query, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. query Object &lt;optional&gt; Passed to Model.findAll. opts Object &lt;optional&gt; Passed to Model.findAll. Source: DataStore.js, line 226 Returns: Type Promise getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Parameters: Name Type Argument Description name string &lt;optional&gt; The name of the adapter to retrieve. Inherited From: Container#getAdapter Source: Container.js, line 233 Returns: The adapter. Type Adapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Parameters: Name Type Argument Description opts Object | string &lt;optional&gt; The name of an adapter or options, if any. Inherited From: Container#getAdapterName Source: Container.js, line 216 Returns: The name of the adapter. Type string getAdapters() Return the registered adapters of this container. Inherited From: Container#getAdapters Source: Container.js, line 251 Returns: Type Adapter getCollection(name) TODO Parameters: Name Type Description name string Name of the DataStoreCollection to retrieve. Source: DataStore.js, line 245 Returns: Type DataStoreCollection getMapper(name) Return the mapper registered under the specified name. Parameters: Name Type Description name string Mapper#name. Inherited From: Container#getMapper Source: Container.js, line 262 Returns: Type Mapper Example import {Container} from 'js-data' const container = new Container() const userMapper = container.defineMapper('user') userMapper === container.getMapper('user') // true registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Parameters: Name Type Argument Description name string The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Inherited From: Container#registerAdapter Source: Container.js, line 284 Example import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() container.registerAdapter('http', new HttpAdapter, { default: true }) update(name, id, record, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. id string | number Passed to Mapper#update. record Object Passed to Mapper#update. opts Object &lt;optional&gt; Passed to Mapper#update. See Mapper#update for more configuration options. Source: DataStore.js, line 261 Returns: Type Promise updateAll(name, query, props, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. query Object &lt;nullable&gt; Passed to Model.updateAll. props Object Passed to Model.updateAll. opts Object &lt;optional&gt; Passed to Model.updateAll. See Model.updateAll for more configuration options. Source: DataStore.js, line 282 Returns: Type Promise updateMany(name, records, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; Passed to Mapper#updateMany. opts Object &lt;optional&gt; Passed to Mapper#updateMany. See Mapper#updateMany for more configuration options. Source: DataStore.js, line 303 Returns: Type Promise × Search results Close Back to js-data.io "},"LinkedCollection.html":{"id":"LinkedCollection.html","title":"Class: LinkedCollection","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: LinkedCollection LinkedCollection new LinkedCollection(records, opts) TODO import {LinkedCollection} from 'js-data' Parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. See Collection. opts Object &lt;optional&gt; Configuration options. See Collection. Source: LinkedCollection.js, line 17 Returns: Type Mapper Extends Collection Members idAttribute :string Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Type: string Inherited From: Collection#idAttribute Default Value: &quot;id&quot; Source: Collection.js, line 21 index :Index The main index, which uses @{link Collection#recordId} as the key. Type: Index Inherited From: Collection#index Source: Collection.js, line 143 indexes :Object.&lt;string, Index&gt; Object that holds the secondary indexes of this collection. Type: Object.&lt;string, Index&gt; Inherited From: Collection#indexes Source: Collection.js, line 154 mapper :Mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#RecordClass. Type: Mapper Inherited From: Collection#mapper Default Value: null Source: Collection.js, line 32 Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict :string What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Type: string Inherited From: Collection#onConflict Default Value: &quot;merge&quot; Source: Collection.js, line 52 recordOpts :Object Options to be passed into Mapper#createRecord when wrapping records in Mapper#RecordClass. Type: Object Inherited From: Collection#recordOpts Default Value: null Source: Collection.js, line 77 Methods &lt;static&gt; extend(props, classProps) Create a LinkedCollection subclass. var MyLinkedCollection = LinkedCollection.extend({ foo: function () { return 'bar' } }) var collection = new MyLinkedCollection() collection.foo() // &quot;bar&quot; Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: LinkedCollection.js, line 161 Returns: Subclass of LinkedCollection. Type function add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description onConflict string &lt;optional&gt; What to do when a record is already in the collection. Possible values are merge or replace. Inherited From: Collection#add Source: Collection.js, line 202 Returns: The added record or records. Type Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Parameters: Name Type Description id string | number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Inherited From: Collection#afterRemove Source: Collection.js, line 306 afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Inherited From: Collection#afterRemoveAll Source: Collection.js, line 318 beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Inherited From: Collection#beforeAdd Source: Collection.js, line 331 beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Parameters: Name Type Description id string | number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Inherited From: Collection#beforeRemove Source: Collection.js, line 343 beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Inherited From: Collection#beforeRemoveAll Source: Collection.js, line 353 between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive boolean &lt;optional&gt; false Whether to include records on the left boundary. limit boolean &lt;optional&gt; Limit the result to a certain number. offset boolean &lt;optional&gt; The number of resulting records to skip. Inherited From: Collection#between Source: Collection.js, line 363 Returns: The result. Type Array Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Parameters: Name Type Argument Description name string The name of the new secondary index. fieldList Array.&lt;string&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Inherited From: Collection#createIndex Source: Collection.js, line 393 Returns: A reference to itself for chaining. Type Collection Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) emit(event, arg) TODO Parameters: Name Type Argument Description event string TODO. arg * &lt;optional&gt; &lt;repeatable&gt; TODO Inherited From: Collection#emit Source: Collection.js, line 773 filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Parameters: Name Type Argument Default Description queryOrFn Object | function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Inherited From: Collection#filter Source: Collection.js, line 424 Returns: The result. Type Array Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Parameters: Name Type Argument Description forEachFn function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Inherited From: Collection#forEach Source: Collection.js, line 459 Returns: The result. Type Array Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Parameters: Name Type Description id string | number The primary key of the record to get. Inherited From: Collection#get Source: Collection.js, line 477 Returns: The record with the given id. Type Object | Record getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Inherited From: Collection#getAll Source: Collection.js, line 490 Returns: The result. Type Array Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Parameters: Name Type Description num number The maximum number of records to keep in the result. Inherited From: Collection#limit Source: Collection.js, line 515 Returns: The result. Type Array Example const posts = collection.limit(10) map(mapFn, thisArg) Apply a mapping function to all records. Parameters: Name Type Argument Description mapFn function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Inherited From: Collection#map Source: Collection.js, line 532 Returns: The result of the mapping. Type Array Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Parameters: Name Type Description funcName string Name of function to call Inherited From: Collection#mapCall Source: Collection.js, line 554 Returns: The result. Type Array method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Inherited From: Collection#method Source: Collection.js, line 294 off(event, handler) TODO Parameters: Name Type Argument Description event string &lt;optional&gt; TODO. handler function &lt;optional&gt; TODO Inherited From: Collection#off Source: Collection.js, line 764 on(event, handler) TODO Parameters: Name Type Description event string TODO. handler function TODO Inherited From: Collection#on Source: Collection.js, line 755 query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Inherited From: Collection#query Source: Collection.js, line 591 Returns: New query object. Type Query Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Inherited From: Collection#recordId Source: Collection.js, line 572 Returns: Primary key or name of field that holds primary key. Type string | number reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Parameters: Name Type Description cb function Reduction callback. initialValue * Initial value of the reduction. Inherited From: Collection#reduce Source: Collection.js, line 610 Returns: The result. Type * Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Parameters: Name Type Argument Description id string | number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Inherited From: Collection#remove Source: Collection.js, line 629 Returns: The removed record, if any. Type Object | Record removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip number &lt;optional&gt; Number to skip. limit number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Inherited From: Collection#removeAll Source: Collection.js, line 660 Returns: The removed records, if any. Type Array.&lt;Object&gt; | Array.&lt;Record&gt; skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Parameters: Name Type Description num number The number of records to skip. Inherited From: Collection#skip Source: Collection.js, line 687 Returns: The result. Type Array Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;string&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Inherited From: Collection#toJSON Source: Collection.js, line 704 Returns: The records. Type Array updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index string &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Inherited From: Collection#updateIndex Source: Collection.js, line 719 updateIndexes(record, opts) TODO Parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Inherited From: Collection#updateIndexes Source: Collection.js, line 738 × Search results Close Back to js-data.io "},"Mapper.html":{"id":"Mapper.html","title":"Class: Mapper","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Mapper Mapper new Mapper(opts) import {Mapper} from 'js-data'The core of JSData's ORM/ODM implementation. Given a minimum amout of meta information about a resource, a Mapper can perform generic CRUD operations against that resource. Apart from its configuration, a Mapper is stateless. The particulars of various persistence layers has been abstracted into adapters, which a Mapper uses to perform its operations. The term &quot;Mapper&quot; comes from the Data Mapper Pattern described in Martin Fowler's Patterns of Enterprise Application Architecture. A Data Mapper moves data between in-memory object instances and a relational or document-based database. JSData's Mapper can work with any persistence layer you can write an adapter for. (&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation to prevent confusion.) Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Source: Mapper.js, line 173 Members debug :boolean Whether to enable debug-level logs. Type: boolean Default Value: false Source: Mapper.js, line 52 defaultAdapter :string The name of the registered adapter that this Mapper should used by default. Type: string Default Value: &quot;http&quot; Source: Mapper.js, line 43 idAttribute :string The field used as the unique identifier on records handled by this Mapper. Type: string Default Value: id Source: Mapper.js, line 61 name :string Minimum amount of meta information required to start operating against a resource. Type: string Source: Mapper.js, line 70 notify :boolean Whether this Mapper should emit operational events. Type: boolean Default Value: true Source: Mapper.js, line 79 raw :boolean Whether Mapper#create, Mapper#createMany, Mapper#save, Mapper#update, Mapper#updateAll, Mapper#updateMany, Mapper#find, Mapper#findAll, Mapper#destroy, and Mapper#destroyAll should return a raw result object that contains both the instance data returned by the adapter and metadata about the operation. The default is to NOT return the result object, and instead return just the instance data. Type: boolean Default Value: false Source: Mapper.js, line 88 RecordClass Set the false to force the Mapper to work with POJO objects only. import {Mapper, Record} from 'js-data' const UserMapper = new Mapper({ RecordClass: false }) UserMapper.RecordClass // false const user = UserMapper#createRecord() user instanceof Record // falseSet to a custom class to have records wrapped in your custom class. import {Mapper, Record} from 'js-data' // Custom class class User { constructor (props = {}) { for (var key in props) { if (props.hasOwnProperty(key)) { this[key] = props[key] } } } } const UserMapper = new Mapper({ RecordClass: User }) UserMapper.RecordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // false user instanceof User // trueExtend the Record class. import {Mapper, Record} from 'js-data' // Custom class class User extends Record { constructor () { super(props) } } const UserMapper = new Mapper({ RecordClass: User }) UserMapper.RecordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // true user instanceof User // true Default Value: Record Source: Mapper.js, line 105 upsert :boolean Whether Mapper#create and Mapper#createMany should instead call Mapper#update and Mapper#updateMany if the provided record(s) already contain a primary key. Type: boolean Default Value: true Source: Mapper.js, line 161 Methods &lt;static&gt; extend(props, classProps) Create a Mapper subclass. var MyMapper = Mapper.extend({ foo: function () { return 'bar' } }) var mapper = new MyMapper() mapper.foo() // &quot;bar&quot; Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: Mapper.js, line 1275 Returns: Subclass of Mapper. Type function afterCreate(data, opts) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Parameters: Name Type Description data Object The data return by the adapter. opts Object The opts argument passed to Mapper#create. Source: Mapper.js, line 485 afterCreateMany(records, opts) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. Source: Mapper.js, line 582 afterDestroy(id, opts) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. Source: Mapper.js, line 1079 afterDestroyAll(data, query, opts) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Parameters: Name Type Description data * The data returned by the adapter. query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. Source: Mapper.js, line 1165 afterFind(id, opts) Mapper lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. Source: Mapper.js, line 658 afterFindAll(data, query, opts) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Parameters: Name Type Description data Object The data returned by the adapter. query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. Source: Mapper.js, line 740 afterUpdate(id, props, opts) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. Source: Mapper.js, line 824 afterUpdateAll(query, props, opts) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Parameters: Name Type Description query Object The query argument passed to Mapper#updateAll. props Object The props argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. Source: Mapper.js, line 997 afterUpdateMany(records, opts) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. Source: Mapper.js, line 909 beforeCreate(props, opts) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. Source: Mapper.js, line 407 beforeCreateMany(records, opts) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. Source: Mapper.js, line 497 beforeDestroy(id, opts) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. Source: Mapper.js, line 1010 beforeDestroyAll(query, opts) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Parameters: Name Type Description query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. Source: Mapper.js, line 1091 beforeFind(id, opts) Mappers lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. Source: Mapper.js, line 594 beforeFindAll(query, opts) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. Source: Mapper.js, line 670 beforeUpdate(id, props, opts) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Parameters: Name Type Description id string | number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. Source: Mapper.js, line 753 beforeUpdateAll(query, props, opts) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Parameters: Name Type Description query Object The query argument passed to Mapper#updateAll. props Object The props argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. Source: Mapper.js, line 921 beforeUpdateMany(records, opts) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. Source: Mapper.js, line 837 belongsTo() Usage: Post.belongsTo(User, { localKey: 'myUserId' }) Comment.belongsTo(User) Comment.belongsTo(Post, { localField: '_post' }) Source: Mapper.js, line 1206 create(props, opts) Create and save a new the record using the provided props. Mapper#beforeCreate will be called before calling the adapter. Mapper#afterCreate will be called after calling the adapter. Parameters: Name Type Argument Description props Object The properties for the new record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the created data. If true return a response object that includes the created data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to create in a cascading create if props contains nested relations. NOT performed in a transaction. Source: Mapper.js, line 425 Returns: Type Promise createMany(records, opts) Given an array of records, batch create them via an adapter. Mapper#beforeCreateMany will be called before calling the adapter. Mapper#afterCreateMany will be called after calling the adapter. Parameters: Name Type Argument Description records Array Array of records to be created in one batch. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the updated data. If true return a response object that includes the updated data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to create in a cascading create if the records to be created have linked/nested relations. NOT performed in a transaction. Source: Mapper.js, line 518 Returns: Type Promise createRecord(props, opts) Create an unsaved, uncached instance of this Mapper's Mapper#RecordClass. Returns props if props is already an instance of Mapper#RecordClass. Parameters: Name Type Argument Description props Object The initial properties of the new unsaved record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate boolean &lt;optional&gt; false Whether to skip validation on the initial properties. Source: Mapper.js, line 264 Returns: The unsaved record. Type Object dbg() Source: Mapper.js, line 1198 destroy(id, opts) Using an adapter, destroy the record with the primary key specified by the id argument. Mapper#beforeDestroy will be called before destroying the record. Mapper#afterDestroy will be called after destroying the record. Parameters: Name Type Argument Description id string | number The primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the ejected data (if any). If true return a response object that includes the ejected data (if any) and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to destroy in a cascading delete. NOT performed in a transaction. Source: Mapper.js, line 1022 Returns: Type Promise destroyAll(name, query, opts) TODO Parameters: Name Type Argument Description name string Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper#destroyAll. opts Object &lt;optional&gt; Passed to Mapper#destroyAll. See Mapper#destroyAll for more configuration options. Source: DataStore.js, line 182 Returns: Type Promise destroyAll(query, opts) Using the query argument, destroy the selected records via an adapter. If no query is provided then all records will be destroyed. Mapper#beforeDestroyAll will be called before destroying the records. Mapper#afterDestroyAll will be called after destroying the records. Parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip number &lt;optional&gt; Number to skip. limit number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the ejected data (if any). If true return a response object that includes the ejected data (if any) and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to destroy in a cascading delete. NOT performed in a transaction. Source: Mapper.js, line 1103 Returns: Type Promise emit(event) Trigger an event on this Mapper. Parameters: Name Type Description event string Name of event to emit. Source: Mapper.js, line 1309 end() TODO Source: Mapper.js, line 232 find(id, opts) Retrieve via an adapter the record with the given primary key. Mapper#beforeFind will be called before calling the adapter. Mapper#afterFind will be called after calling the adapter. Parameters: Name Type Argument Description id string | number The primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the updated data. If true return a response object that includes the updated data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to eager load in the request. Source: Mapper.js, line 606 Returns: Type Promise findAll(query, opts) Using the query argument, select records to pull from an adapter. Expects back from the adapter the array of selected records. Mapper#beforeFindAll will be called before calling the adapter. Mapper#afterFindAll will be called after calling the adapter. Parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip number &lt;optional&gt; Number to skip. limit number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the resulting data. If true return a response object that includes the resulting data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to eager load in the request. Source: Mapper.js, line 682 Returns: Type Promise getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Parameters: Name Type Argument Description name string &lt;optional&gt; The name of the adapter to retrieve. Source: Mapper.js, line 359 Returns: The adapter. Type Adapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Parameters: Name Type Argument Description opts Object | string &lt;optional&gt; The name of an adapter or options, if any. Source: Mapper.js, line 378 Returns: The name of the adapter. Type string getAdapters() Source: Mapper.js, line 395 hasMany() Usage: User.hasMany(Post, { localField: 'my_posts' }) Source: Mapper.js, line 1225 hasOne() Usage: User.hasOne(Profile, { localField: '_profile' }) Source: Mapper.js, line 1239 is(record) Return whether record is an instance of this Mappers's RecordClass. Parameters: Name Type Description record Object The record to check. Source: Mapper.js, line 285 Returns: Whether record is an instance of this Mappers's {@ link Mapper#RecordClass}. Type boolean log() Source: Mapper.js, line 1178 off() Remove an event listener from this Mapper. Source: Mapper.js, line 1302 on() Register a new event listener on this Mapper. Source: Mapper.js, line 1295 registerAdapter(name, adapter, opts) Register an adapter on this mapper under the given name. Parameters: Name Type Argument Description name string The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default boolean &lt;optional&gt; false Whether to make the adapter the default adapter for this Mapper. Source: Mapper.js, line 1253 toJSON(record, opts) Return a plain object representation of the given record. Parameters: Name Type Argument Description record Object Record from which to create a plain object representation. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;string&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Source: Mapper.js, line 299 Returns: Plain object representation of the record. Type Object update(id, props, opts) Using an adapter, update the record with the primary key specified by the id argument. Mapper#beforeUpdate will be called before updating the record. Mapper#afterUpdate will be called after updating the record. Parameters: Name Type Argument Description id string | number The primary key of the record to update. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the updated data. If true return a response object that includes the updated data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to update in a cascading update if props contains nested updates to relations. NOT performed in a transaction. Source: Mapper.js, line 766 Returns: Type Promise updateAll(query, props, opts) Using the query argument, perform the a single updated to the selected records. Expects back from the adapter an array of the updated records. Mapper#beforeUpdateAll will be called before making the update. Mapper#afterUpdateAll will be called after making the update. Parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip number &lt;optional&gt; Number to skip. limit number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. props Object Update to apply to selected records. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the updated data. If true return a response object that includes the updated data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to update in a cascading update if props contains nested updates to relations. NOT performed in a transaction. Source: Mapper.js, line 934 Returns: Type Promise updateMany(records, opts) Given an array of updates, perform each of the updates via an adapter. Each &quot;update&quot; is a hash of properties with which to update an record. Each update must contain the primary key to be updated. Mapper#beforeUpdateMany will be called before making the update. Mapper#afterUpdateMany will be called after making the update. Parameters: Name Type Argument Description records Array Array up record updates. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description adapter boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify boolean &lt;optional&gt; Mapper#notify Whether to emit lifecycle events. raw boolean &lt;optional&gt; Mapper#raw If false, return the updated data. If true return a response object that includes the updated data and metadata about the operation. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to update in a cascading update if each record update contains nested updates for relations. NOT performed in a transaction. Source: Mapper.js, line 849 Returns: Type Promise × Search results Close Back to js-data.io "},"module-js-data.html":{"id":"module-js-data.html","title":"Module: js-data","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Module: js-data Registered as js-data in NPM and Bower. Script tagwindow.JSDataCommonJSvar JSData = require('js-data')ES6 Modulesimport JSData from 'js-data'AMDdefine('myApp', ['js-data'], function (JSData) { ... }) Source: index.js, line 1 Members &lt;static&gt; Collection Collection class. Source: index.js, line 47 &lt;static&gt; Container Container class. Source: index.js, line 52 &lt;static&gt; DataStore DataStore class. Source: index.js, line 57 &lt;static&gt; LinkedCollection LinkedCollection class. Source: index.js, line 62 &lt;static&gt; Mapper Mapper class. Source: index.js, line 67 &lt;static&gt; Query Query class. Source: index.js, line 72 &lt;static&gt; Record Record class. Source: index.js, line 77 &lt;static&gt; Schema Schema class. Source: index.js, line 82 &lt;static&gt; utils :Object Type: Object Properties: Name Type Description addHiddenPropsToTarget function TODO classCallCheck function TODO copy function TODO deepMixIn function TODO eventify function TODO extend function TODO fillIn function TODO fromJson function TODO get function TODO getSuper function TODO intersection function TODO isArray function TODO isBlacklisted function TODO isBrowser boolean TODO isBoolean function TODO isFunction function TODO isInteger function TODO isNull function TODO isNumber function TODO isObject function TODO isRegExp function TODO isSorN function TODO isString function TODO isUndefined function TODO possibleConstructorReturn function TODO reject function TODO resolve function TODO set function TODO toJson function TODO uuid function TODO Source: utils.js, line 1 &lt;static&gt; version :Object Details of the current version of the js-data module. Type: Object Properties: Name Type Description full string The full semver value. major number The major version number. minor number The minor version number. patch number The patch version number. alpha string | boolean The alpha version value, otherwise false if the current version is not alpha. beta string | boolean The beta version value, otherwise false if the current version is not beta. Source: index.js, line 23 Methods &lt;static&gt; belongsTo(related, opts) TODO Parameters: Name Type Description related Mapper The relation the target belongs to. opts Object Configuration options. Properties Name Type Description foreignKey string The field that holds the primary key of the related record. localField string The field that holds a reference to the related record object. Source: decorators.js, line 59 Returns: Invocation function, which accepts the target as the only parameter. Type function &lt;static&gt; hasMany(related, opts) TODO Parameters: Name Type Description related Mapper The relation of which the target has many. opts Object Configuration options. Properties Name Type Argument Description foreignKey string &lt;optional&gt; The field that holds the primary key of the related record. localField string The field that holds a reference to the related record object. Source: decorators.js, line 81 Returns: Invocation function, which accepts the target as the only parameter. Type function &lt;static&gt; hasOne(related, opts) TODO Parameters: Name Type Description related Mapper The relation of which the target has one. opts Object Configuration options. Properties Name Type Argument Description foreignKey string &lt;optional&gt; The field that holds the primary key of the related record. localField string The field that holds a reference to the related record object. Source: decorators.js, line 103 Returns: Invocation function, which accepts the target as the only parameter. Type function × Search results Close Back to js-data.io "},"Query.html":{"id":"Query.html","title":"Class: Query","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Query Query new Query(collection) A class used by the Collection class to build queries to be executed against the collection's data. An instance of Query is returned by Collection#query. import {Query} from 'js-data' Parameters: Name Type Description collection Collection The collection on which this query operates. Source: Query.js, line 16 Members &lt;static&gt; ops :Object TODO Type: Object Source: Query.js, line 85 collection :Collection The collection on which this query operates. Type: Collection Source: Query.js, line 31 data :Array The data result of this query. Type: Array Source: Query.js, line 39 Methods &lt;static&gt; extend(props, classProps) Create a Query subclass. var MyQuery = Query.extend({ foo: function () { return 'bar' } }) var query = new MyQuery() query.foo() // &quot;bar&quot; Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: Query.js, line 48 Returns: Subclass of Query. Type function between(leftKeys, rightKeys, opts) Find all entities between two boundaries. Get the users ages 18 to 30 const users = query.between(18, 30, { index: 'age' }).run()Same as above const users = query.between([18], [30], { index: 'age' }).run() Parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive boolean &lt;optional&gt; true Whether to include entities on the left boundary. rightInclusive boolean &lt;optional&gt; false Whether to include entities on the left boundary. limit boolean &lt;optional&gt; Limit the result to a certain number. offset boolean &lt;optional&gt; The number of resulting entities to skip. Source: Query.js, line 204 Returns: A reference to itself for chaining. Type Query filter(queryOrFn, thisArg) Find the entity or entities that match the provided query or pass the provided filter function. ExampleGet the draft posts created less than three months const posts = query.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }).run()Use a custom filter function const posts = query.filter(function (post) { return post.isReady() }).run() Parameters: Name Type Argument Default Description queryOrFn Object | function &lt;optional&gt; {} Selection query or filter function. thisArg function &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Source: Query.js, line 341 Returns: A reference to itself for chaining. Type Query forEach(forEachFn, thisArg) Iterate over all entities. Parameters: Name Type Argument Description forEachFn function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Source: Query.js, line 522 Returns: A reference to itself for chaining. Type Query get(keyList, opts) Find the entity or entities that match the provided key. ExampleGet the entity whose primary key is 25 const entities = query.get(25).run()Same as above const entities = query.get([25]).run()Get all users who are active and have the &quot;admin&quot; role const activeAdmins = query.get(['active', 'admin'], { index: 'activityAndRoles' }).run()Get all entities that match a certain weather condition const niceDays = query.get(['sunny', 'humid', 'calm'], { index: 'weatherConditions' }).run() Parameters: Name Type Argument Description keyList Array Key(s) defining the entity to retrieve. If keyList is not an array (i.e. for a single-value key), it will be wrapped in an array. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description string string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Source: Query.js, line 242 Returns: A reference to itself for chaining. Type Query getAll(keyList, opts) Find the entity or entities that match the provided keyLists. ExampleGet the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = query.getAll('draft', 'inReview', { index: 'status' }).run()Same as above const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() Parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all entities matching each keyList will be retrieved. If no keyLists are provided, all entities will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index string &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Source: Query.js, line 296 Returns: A reference to itself for chaining. Type Query getData() Return the current data result of this query. Source: Query.js, line 191 Returns: The data in this query. Type Array limit(num) Limit the result. ExampleGet only the first 10 draft posts const posts = query.get('draft', { index: 'status' }).limit(10).run() Parameters: Name Type Description num number The maximum number of entities to keep in the result. Source: Query.js, line 498 Returns: A reference to itself for chaining. Type Query map(mapFn, thisArg) Apply a mapping function to the result data. Parameters: Name Type Argument Description mapFn function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Source: Query.js, line 536 Returns: A reference to itself for chaining. Type Query mapCall(funcName) Return the result of calling the specified function on each item in this collection's main index. Parameters: Name Type Description funcName string Name of function to call Source: Query.js, line 550 Returns: A reference to itself for chaining. Type Query run() Complete the execution of the query and return the resulting data. Source: Query.js, line 566 Returns: The result of executing this query. Type Array skip(num) Skip a number of results. ExampleGet all but the first 10 draft posts const posts = query.get('draft', { index: 'status' }).skip(10).run() Parameters: Name Type Description num number The number of entities to skip. Source: Query.js, line 470 Returns: A reference to itself for chaining. Type Query × Search results Close Back to js-data.io "},"Record.html":{"id":"Record.html","title":"Class: Record","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Record Record new Record(props, opts) js-data's Record class. import {Record} from 'js-data' Parameters: Name Type Argument Description props Object &lt;optional&gt; The initial properties of the new Record instance. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate boolean &lt;optional&gt; false Whether to skip validation on the initial properties. Source: Record.js, line 19 Methods &lt;static&gt; extend(props, classProps) Create a Record subclass. var MyRecord = Record.extend({ foo: function () { return 'bar' } }) var record = new MyRecord() record.foo() // &quot;bar&quot; Parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Source: Record.js, line 62 Returns: Subclass of Record. Type function afterLoadRelations(relations, opts) TODO Parameters: Name Type Description relations Array.&lt;string&gt; TODO opts Object TODO Source: Record.js, line 432 afterSave(opts) TODO Parameters: Name Type Description opts Object TODO Source: Record.js, line 332 beforeLoadRelations(relations, opts) TODO Parameters: Name Type Description relations Array.&lt;string&gt; TODO opts Object TODO Source: Record.js, line 341 beforeSave(opts) TODO Parameters: Name Type Description opts Object TODO Source: Record.js, line 280 changes(key) TODO Parameters: Name Type Argument Description key string &lt;optional&gt; TODO Source: Record.js, line 159 commit() TODO Source: Record.js, line 184 create(opts) TODO Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Mapper#create. Source: Record.js, line 269 destroy(opts) TODO Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. @see Model.destroy. Source: Record.js, line 442 emit(event) Trigger an event on this Record. Parameters: Name Type Description event string Name of event to emit. Source: Record.js, line 476 get(key) Return the value at the given path for this instance. Parameters: Name Type Description key string Path of value to retrieve. Source: Record.js, line 97 Returns: Value at path. Type * hasChanges() TODO Source: Record.js, line 174 hashCode() TODO Source: Record.js, line 148 loadRelations(relations, opts) TODO Parameters: Name Type Argument Description relations Array.&lt;string&gt; &lt;optional&gt; TODO opts Object &lt;optional&gt; TODO Source: Record.js, line 351 off() Remove an event listener from this Record. Source: Record.js, line 469 on() Register a new event listener on this Record. Source: Record.js, line 462 previous(key) TODO Parameters: Name Type Argument Description key string &lt;optional&gt; TODO Source: Record.js, line 198 revert(opts) TODO Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Source: Record.js, line 213 save(opts) TODO Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Mapper#create. Source: Record.js, line 289 schema(key) TODO Parameters: Name Type Argument Description key string &lt;optional&gt; TODO Source: Record.js, line 239 set(key, value, opts) Set the value for a given key, or the values for the given keys if &quot;key&quot; is an object. Parameters: Name Type Argument Description key string | Object Key to set or hash of key-value pairs to set. value * &lt;optional&gt; Value to set for the given key. opts Object &lt;optional&gt; Optional configuration. Properties Name Type Argument Default Description silent boolean &lt;optional&gt; false Whether to trigger change events. Source: Record.js, line 109 unset(key, opts) Unset the value for a given key. Parameters: Name Type Argument Description key string Key to unset. opts Object &lt;optional&gt; Optional configuration. Properties Name Type Argument Default Description silent boolean &lt;optional&gt; false Whether to trigger change events. Source: Record.js, line 135 × Search results Close Back to js-data.io "},"Schema.html":{"id":"Schema.html","title":"Class: Schema","body":" js-data Modules js-data Classes CollectionContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Schema Schema new Schema(definition) js-data's Schema class. import {Schema} from 'js-data' Parameters: Name Type Description definition Object Schema definition according to json-schema.org Source: Schema.js, line 18 Members &lt;static&gt; typeGroupValidators :Object TODO Type: Object Source: Schema.js, line 64 &lt;static&gt; types :Object TODO Type: Object Source: Schema.js, line 48 &lt;static&gt; validationKeywords :Object TODO Type: Object Source: Schema.js, line 72 Methods &lt;static&gt; extend() Source: Schema.js, line 42 &lt;static&gt; validate(value, schema, opts) TODO Parameters: Name Type Argument Description value * TODO schema Object &lt;optional&gt; TODO opts Object &lt;optional&gt; Configuration options. Source: Schema.js, line 181 validate(value, opts) Validate the provided value against this schema. Parameters: Name Type Argument Description value * Value to validate. opts Object &lt;optional&gt; Configuration options. Source: Schema.js, line 244 Returns: Array of errors or undefined if valid. Type array | undefined × Search results Close Back to js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
